!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Mikko Lyly
! *  Email:   Juha.Ruokolainen@csc.fi, Mikko.Lyly@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/



!------------------------------------------------------------------------------
!> Initialization for the primary solver: ElasticSolver. 
!------------------------------------------------------------------------------
SUBROUTINE ElasticSolver_Init( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------
    USE DefUtils
    IMPLICIT NONE

    TYPE(Model_t)  :: Model
    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: DT
    LOGICAL :: Transient
!------------------------------------------------------------------------------
    INTEGER :: dim,i
    TYPE(ValueList_t), POINTER :: SolverParams
    LOGICAL :: Found, CalculateStrains, CalcPrincipalAngle, CalcPrincipalAll, &
        CalcStressAll
!------------------------------------------------------------------------------

    SolverParams => GetSolverParams()
    IF ( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN
      dim = CoordinateSystemDimension()
      CALL ListAddInteger( SolverParams, 'Variable DOFs', dim )
      CALL ListAddString( SolverParams, 'Variable', 'Displacement' )
    END IF
    CALL ListAddInteger( SolverParams, 'Time derivative order', 2 )

    CalculateStrains = GetLogical(SolverParams, 'Calculate Strains', Found)
    CalcPrincipalAngle = GetLogical(SolverParams, 'Calculate PAngle', Found)
    CalcPrincipalAll = GetLogical(SolverParams, 'Calculate Principal', Found)
    CalcStressAll = GetLogical( SolverParams, 'Calculate Stresses',Found )
    IF(CalcPrincipalAngle) CalcPrincipalAll = .TRUE. ! can't calculate angle without principal
    IF(CalcPrincipalAll)   CalcStressAll = .TRUE. ! can't calculate principal without components
    IF(CalculateStrains)   CalcStressAll = .TRUE. ! can't calculate principal without components
    
    ! If stress computation is requested somewhere then enforce it 
    IF( .NOT. ( CalcStressAll .OR. CalculateStrains) ) THEN
      CalcStressAll = ListGetLogicalAnyEquation( Model,'Calculate Stresses')
      IF( CalcStressAll ) CALL ListAddLogical( SolverParams,'Calculate Stresses',.TRUE.)
    END IF


    IF ( CalcStressAll ) THEN
      CALL ListAddString( SolverParams,&
          NextFreeKeyword('Exported Variable ',SolverParams), &
          'Stress[Stress_xx:1 Stress_yy:1 Stress_zz:1 Stress_xy:1 Stress_yz:1 Stress_xz:1]' )
      CALL ListAddString( SolverParams,&
          NextFreeKeyword('Exported Variable ',SolverParams), &
          'vonMises' )
      
      IF(CalcPrincipalAll) THEN
        CALL ListAddString( SolverParams,&
            NextFreeKeyword('Exported Variable ',SolverParams), &
            'Principal Stress[Principal Stress:3]' )
        CALL ListAddString( SolverParams,&
            NextFreeKeyword('Exported Variable ',SolverParams), &
            'Tresca' )
        
        IF(CalcPrincipalAngle) THEN
          CALL ListAddString( SolverParams,&
              NextFreeKeyword('Exported Variable ',SolverParams), &
              '-dofs 9 Principal Angle' )
        END IF ! PrincipalAngle
      END IF !CalcPrincipalAll      
    END IF ! CalcStressAll
    
    IF(CalculateStrains) THEN
      CALL ListAddString( SolverParams,&
          NextFreeKeyword('Exported Variable ',SolverParams), &
          'Strain[Strain_xx:1 Strain_yy:1 Strain_zz:1 Strain_xy:1 Strain_yz:1 Strain_xz:1]' )
      IF(CalcPrincipalAll) THEN
        CALL ListAddString( SolverParams,&
            NextFreeKeyword('Exported Variable ',SolverParams), &
            'Principal Strain[Principal Strain:3]' )
      END IF
    END IF


!------------------------------------------------------------------------------
  END SUBROUTINE ElasticSolver_Init
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!>  Solver for the general non-linear elasticity equations.
!> \ingroup Solvers
!------------------------------------------------------------------------------
   SUBROUTINE ElasticSolver( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------

    USE Adaptive
    USE DefUtils
    USE MaterialModels
    USE StressLocal

    IMPLICIT NONE

!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t), TARGET :: Solver
     LOGICAL ::  TransientSimulation
     REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
     TYPE(Matrix_t),POINTER :: StiffMatrix

     INTEGER :: i,j,k,l,m,n,t,iter,NDeg,k1,k2,STDOFs,LocalNodes,istat

     TYPE(Solver_t), POINTER :: PSolver

     TYPE(ValueList_t), POINTER :: Material
     TYPE(Nodes_t) :: ElementNodes,ParentNodes,FlowNodes
     TYPE(Element_t),POINTER :: CurrentElement, ParentElement, FlowElement

     REAL(KIND=dp) :: RelativeChange, UNorm, Gravity(3), TransformMatrix(3,3), &
         Tdiff,Normal(3),NewtonTol,s,TOL(1), UnitNorm

     INTEGER :: NewtonIter,NonlinearIter, FlowNOFNodes

     TYPE(Variable_t), POINTER :: StressSol, TempSol, FlowSol, Var

     REAL(KIND=dp), POINTER :: Temperature(:),Pressure(:),Displacement(:), UWrk(:,:), &
          Work(:,:), ForceVector(:), Velocity(:,:), FlowSolution(:), SaveValues(:), &
          NodalStrain(:), NodalStress(:), VonMises(:), &
          PrincipalStress(:), PrincipalStrain(:), Tresca(:), &   ! needed for principal strain calculation
          PrincipalAngle(:), PrincipalAngleComp(:), &            ! needed for principal angle calculation
          PrincipalStressComp(:), PrincipalStrainComp(:)          

     INTEGER,POINTER :: TempPerm(:),StressPerm(:),PressPerm(:),NodeIndexes(:), &
          FlowPerm(:),AdjacentNodes(:)

     INTEGER :: StressType
     LOGICAL :: GotForceBC, GotIt, NewtonLinearization = .FALSE., Isotropic = .TRUE., &
          RotateModuli, LinearModel = .FALSE., MeshDisplacementActive, NeoHookeanMaterial = .FALSE.

     INTEGER :: body_id,bf_id,eq_id,CoordinateSystem
     LOGICAL :: PlaneStress, CalculateStrains, CalcStressAll, CalcPrincipalAll, CalcPrincipalAngle
!
     LOGICAL :: AllocationsDone = .FALSE.

     CHARACTER(LEN=MAX_NAME_LEN) :: str, CompressibilityFlag
     LOGICAL :: CompressibilityDefined = .FALSE.
     TYPE(ValueList_t), POINTER :: SolverParams
     TYPE(Mesh_t), POINTER :: Mesh
!------------------------------------------------------------------------------



     REAL(KIND=dp),ALLOCATABLE:: LocalMassMatrix(:,:),LocalStiffMatrix(:,:),&
          LocalDampMatrix(:,:),LoadVector(:,:),InertialLoad(:,:), Viscosity(:),LocalForce(:), &
          LocalTemperature(:),ElasticModulus(:,:,:),PoissonRatio(:), Density(:), &
          Damping(:), HeatExpansionCoeff(:,:,:),Alpha(:,:),Beta(:), &
          ReferenceTemperature(:),BoundaryDispl(:),LocalDisplacement(:,:), PrevSOL(:)

     SAVE LocalMassMatrix,LocalStiffMatrix,LocalDampMatrix,LoadVector,InertialLoad, Viscosity, &
          LocalForce,ElementNodes,ParentNodes,FlowNodes,Alpha,Beta, &
          LocalTemperature,AllocationsDone,ReferenceTemperature,BoundaryDispl, &
          ElasticModulus, PoissonRatio,Density,Damping,HeatExpansionCoeff, &
          LocalDisplacement, Velocity, Pressure, PrevSOL, CalculateStrains, CalcStressAll, &
          NodalStrain, NodalStress, VonMises, PrincipalStress, PrincipalStrain, Tresca, &
          PrincipalAngle, PrincipalAngleComp, CalcPrincipalAngle, CalcPrincipalAll
!-----------------------------------------------------------------------------------------------------

     REAL(KIND=dp) :: at,at0,CPUTime,RealTime
     INTEGER :: TotalSteps,LoadStep, dim

     CHARACTER(LEN=MAX_NAME_LEN) :: EquationName

     INTERFACE
        FUNCTION ElastBoundaryResidual( Model,Edge,Mesh,Quant,Perm, Gnorm ) RESULT(Indicator)
          USE Types
          TYPE(Element_t), POINTER :: Edge
          TYPE(Model_t) :: Model
          TYPE(Mesh_t), POINTER :: Mesh
          REAL(KIND=dp) :: Quant(:), Indicator(2), Gnorm
          INTEGER :: Perm(:)
        END FUNCTION ElastBoundaryResidual

        FUNCTION ElastEdgeResidual( Model,Edge,Mesh,Quant,Perm ) RESULT(Indicator)
          USE Types
          TYPE(Element_t), POINTER :: Edge
          TYPE(Model_t) :: Model
          TYPE(Mesh_t), POINTER :: Mesh
          REAL(KIND=dp) :: Quant(:), Indicator(2)
          INTEGER :: Perm(:)
        END FUNCTION ElastEdgeResidual

        FUNCTION ElastInsideResidual( Model,Element,Mesh,Quant,Perm, Fnorm ) RESULT(Indicator)
          USE Types
          TYPE(Element_t), POINTER :: Element
          TYPE(Model_t) :: Model
          TYPE(Mesh_t), POINTER :: Mesh
          REAL(KIND=dp) :: Quant(:), Indicator(2), Fnorm
          INTEGER :: Perm(:)
        END FUNCTION ElastInsideResidual
     END INTERFACE


!------------------------------------------------------------------------------
!    Get variables needed for solution
!------------------------------------------------------------------------------
     CALL Info( 'ElasticSolve', 'Starting Solver', Level=10 )
     IF ( .NOT. ASSOCIATED( Solver % Matrix ) ) RETURN

     SolverParams => GetSolverParams()
     Mesh => GetMesh()
     dim = CoordinateSystemDimension()
     CoordinateSystem = CurrentCoordinateSystem()

     StressSol => Solver % Variable
     StressPerm     => StressSol % Perm
     STDOFs         =  StressSol % DOFs
     Displacement   => StressSol % Values

     LocalNodes = COUNT( StressPerm > 0 )
     IF ( LocalNodes <= 0 ) RETURN

     TempSol => VariableGet( Mesh % Variables, 'Temperature' )
     IF ( ASSOCIATED( TempSol) ) THEN
       TempPerm    => TempSol % Perm
       Temperature => TempSol % Values
     END IF

     FlowSol => VariableGet( Mesh % Variables, 'Flow Solution' )
     IF ( ASSOCIATED( FlowSol) ) THEN
       FlowPerm => FlowSol % Perm
       k = SIZE( FlowSol % Values )
       FlowSolution => FlowSol % Values
     END IF

     MeshDisplacementActive = ListGetLogical( SolverParams, &
                 'Displace Mesh', GotIt )
     IF ( .NOT. GotIt ) &
       MeshDisplacementActive = .NOT.EigenOrHarmonicAnalysis()

     IF ( AllocationsDone .AND. MeshDisplacementActive ) THEN
        CALL DisplaceMesh( Mesh, Displacement, -1, StressPerm, STDOFs )
     END IF

     StiffMatrix => Solver % Matrix
     ForceVector => StiffMatrix % RHS

!------------------------------------------------------------------------------
!     Allocate some permanent storage, this is done first time only
!------------------------------------------------------------------------------
     IF ( .NOT. AllocationsDone .OR. Mesh % Changed ) THEN
       N = Mesh % MaxElementNodes

       IF ( AllocationsDone ) THEN
          DEALLOCATE( &
                 BoundaryDispl, &
                 ReferenceTemperature, &
                 HeatExpansionCoeff, &
                 LocalTemperature, &
                 Pressure, Velocity, &
                 ElasticModulus, PoissonRatio, &
                 Density, Damping, &
                 LocalForce, Viscosity, &
                 LocalMassMatrix,  &
                 LocalStiffMatrix,  &
                 LocalDampMatrix,  &
                 LoadVector, InertialLoad, Alpha, Beta, &
                 LocalDisplacement )
       END IF

       ALLOCATE( &
                 BoundaryDispl( N ), &
                 ReferenceTemperature( N ), &
                 HeatExpansionCoeff( 3,3,N ), &
                 LocalTemperature( N ), &
                 Pressure( N ), Velocity( 3,N ), &
                 ElasticModulus( 6,6,N ), PoissonRatio( N ), &
                 Density( N ), Damping( N ), &
                 LocalForce( STDOFs*N ), Viscosity( N ), &
                 LocalMassMatrix(  STDOFs*N,STDOFs*N ),  &
                 LocalStiffMatrix( STDOFs*N,STDOFs*N ),  &
                 LocalDampMatrix( STDOFs*N,STDOFs*N ),  &
                 LoadVector( 4,N ), InertialLoad(3,N), Alpha( 3,N ), Beta( N ), &
                 LocalDisplacement( 3,N ), STAT=istat )

       IF ( istat /= 0 ) THEN
         CALL Fatal( 'ElasticSolve',  'Memory allocation error.' )
       END IF

       !----------------------------------------------------------------
       ! Check whether strains and stresses are computed...
       !----------------------------------------------------------------

       CalculateStrains = GetLogical(SolverParams, 'Calculate Strains', GotIt )    
       CalcPrincipalAngle = GetLogical(SolverParams, 'Calculate PAngle', GotIt )
       CalcPrincipalAll = GetLogical(SolverParams, 'Calculate Principal', GotIt )     
       CalcStressAll = GetLogical(SolverParams, 'Calculate Stresses', GotIt )          
       IF(CalcPrincipalAngle) CalcPrincipalAll = .TRUE. ! can't calculate angle without principal
       IF(CalcPrincipalAll)   CalcStressAll = .TRUE. ! can't calculate principal without components
       IF(CalculateStrains)   CalcStressAll = .TRUE. ! can't calculate principal without components

!------------------------------------------------------------------------------
       AllocationsDone = .TRUE.
     END IF
       


     IF ( CalcStressAll ) THEN
       Var => VariableGet( Mesh % Variables, 'Stress',.TRUE. )
       IF ( ASSOCIATED( Var ) ) THEN
         StressPerm  => Var % Perm
         NodalStress => Var % Values
       ELSE  
         CALL Fatal('StressSolver','Variable > Stress < does not exits!')
       END IF
       
       Var => VariableGet( Mesh % Variables, 'VonMises',.TRUE. )
       IF ( ASSOCIATED( Var ) ) THEN
         VonMises => Var % Values
       ELSE
         CALL Fatal('StressSolver','Variable > vonMises < does not exits!')
       END IF
       
       IF(CalcPrincipalAll) THEN
         Var => VariableGet( Mesh % Variables, 'Principal Stress',.TRUE. )
         IF ( ASSOCIATED( Var ) ) THEN
           PrincipalStress => Var % Values
         ELSE                 
           CALL Fatal('StressSolver','Variable > Principal Stress < does not exits!')
         END IF
         
         Var => VariableGet( Mesh % Variables, 'Tresca',.TRUE. )
         IF ( ASSOCIATED( Var ) ) THEN
           Tresca => Var % Values
         ELSE
           CALL Fatal('StressSolver','Variable > Tresca < does not exits!')
         END IF
         
         IF(CalcPrincipalAngle) THEN
           Var => VariableGet( Mesh % Variables, 'Principal Angle' )                 
           IF ( ASSOCIATED( Var ) ) THEN
             PrincipalAngle => Var % Values
           ELSE
             CALL Fatal('StressSolver','Variable > Principal Angle < does not exits!')
           END IF
         END IF ! PrincipalAngle
       END IF !CalcPrincipalAll             
     END IF ! CalcStress or CalcStressAll
     
     IF(CalculateStrains) THEN
       Var => VariableGet( Mesh % Variables, 'Strain' )
       IF ( ASSOCIATED( Var ) ) THEN
         NodalStrain => Var % Values
       ELSE
         CALL Fatal('StressSolver','Variable > Strain < does not exits!')
       END IF
       IF(CalcPrincipalAll) THEN
         Var => VariableGet( Mesh % Variables, 'Principal Strain' )
         IF ( ASSOCIATED( Var ) ) THEN
           PrincipalStrain => Var % Values
         ELSE
           CALL Fatal('StressSolver','Variable > Principal Strain < does not exits!')
         END IF
       END IF
     END IF !Calculate strains

     
     ALLOCATE( PrevSOL(SIZE(Displacement)) )
     PrevSOL = Displacement

!------------------------------------------------------------------------------
!    Do some additional initialization, and go for it
!------------------------------------------------------------------------------
!    Work => ListGetConstRealArray( Model % Constants,'Gravity',GotIt )
!    IF ( GotIt ) THEN
!      Gravity = Work(1,1:3)*Work(1,4)
!    ELSE
!      Gravity    =  0.0D0
!      Gravity(2) = -9.81D0
!    END IF
!------------------------------------------------------------------------------


!     NewtonTol = ListGetConstReal( SolverParams, &
!        'Nonlinear System Newton After Tolerance' )

!     NewtonIter = ListGetInteger( SolverParams, &
!        'Nonlinear System Newton After Iterations' )

     NonlinearIter = ListGetInteger( SolverParams, &
         'Nonlinear System Max Iterations',GotIt )

     IF ( .NOT.GotIt ) NonlinearIter = 1

     LinearModel = ListGetLogical( SolverParams, &
          'Elasticity Solver Linear', GotIt )

     NeoHookeanMaterial = ListGetLogical( SolverParams, &
          'Neo-Hookean Material', GotIt )

     IF( ListGetLogical( SolverParams, 'Eigen Analysis',GotIt) ) &
          LinearModel = .TRUE.

     EquationName = ListGetString( SolverParams, 'Equation' )
!------------------------------------------------------------------------------

     DO iter=1,NonlinearIter

       at  = CPUTime()
       at0 = RealTime()

       CALL Info( 'ElasticSolve', ' ', Level=4 )
       CALL Info( 'ElasticSolve', ' ', Level=4 )
       CALL Info( 'ElasticSolve', &
           '-------------------------------------', Level=4 )
       WRITE( Message, * ) 'ELASTICITY ITERATION   ', iter
       CALL Info( 'ElasticSolve', Message, Level=4 )
       CALL Info( 'ElasticSolve', &
           '-------------------------------------', Level=4 )
       CALL Info( 'ElasticSolve', ' ', Level=4 )
       CALL Info( 'ElasticSolve', 'Starting assembly...', Level=4 )

!------------------------------------------------------------------------------
       CALL DefaultInitialize()
!------------------------------------------------------------------------------
       t = 1
       DO t=1,GetNOFActive()

         IF ( RealTime() - at0 > 1.0 ) THEN
           WRITE(Message,'(a,i3,a)' ) '   Assembly: ', INT(100.0 - 100.0 * &
            (Solver % NumberOfActiveElements-t) / &
               (1.0*Solver % NumberOfActiveElements)), ' % done'
                       
           CALL Info( 'ElasticSolve', Message, Level=5 )

           at0 = RealTime()
         END IF
!------------------------------------------------------------------------------
!        Check if this element belongs to a body where displacements
!        should be calculated
!------------------------------------------------------------------------------
         CurrentElement => GetActiveElement(t)
!
!        Ok, we´ve got one for stress computations
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
         body_id = CurrentElement % BodyId
         n = GetElementNOFNodes()
         NodeIndexes => CurrentElement % NodeIndexes

         eq_id = ListGetInteger( Model % Bodies(body_id) % Values, 'Equation', &
              minv=1, maxv=Model % NumberOfEquations )
         PlaneStress = ListGetLogical( Model % Equations(eq_id) % Values, &
                         'Plane Stress',gotIt )

         CALL GetElementNodes(ElementNodes, CurrentElement)

         k = ListGetInteger( Model % Bodies(body_id) % Values,'Material', &
                   minv=1, maxv=Model % NumberOFMaterials )
         Material => Model % Materials(k) % Values

!         ElasticModulus(1:n) = ListGetReal( Material, &
!              'Youngs Modulus',n,NodeIndexes )

         IF (NeoHookeanMaterial) THEN
            Isotropic = .TRUE.
            ElasticModulus(1,1,1:n) = ListGetReal( Material, &
                 'Youngs Modulus', n, NodeIndexes, GotIt )
         ELSE
            CALL InputTensor( ElasticModulus, Isotropic, &
                 'Youngs Modulus', Material, n, NodeIndexes )        
         END IF

         PoissonRatio = 0.0d0
         IF (Isotropic) PoissonRatio(1:n) = ListGetReal( Material, &
              'Poisson Ratio',n,NodeIndexes )

         Density(1:n) = ListGetReal( Material, &
              'Density',n,NodeIndexes,GotIt )

         Damping(1:n) = ListGetReal( Material, &
              'Damping',n,NodeIndexes,GotIt )

         HeatExpansionCoeff   = 0.0D0
         DO i=1,3
           HeatExpansionCoeff(i,i,1:n) = ListGetReal( Material,&
             'Heat Expansion Coefficient',n,NodeIndexes,gotIt )
         END DO

         ReferenceTemperature(1:n) = ListGetReal( Material, &
              'Reference Temperature',n,NodeIndexes,gotIt )

         !------------------------------------------------------------------------------
         ! Check whether the rotation transformation of elastic moduli is necessary...
         !------------------------------------------------------------------------------
         RotateModuli = GetLogical( Material, 'Rotate Elasticity Tensor', GotIt )
         IF ( RotateModuli ) THEN
            RotateModuli = .FALSE.
            DO i=1,3
               IF( i == 1 ) THEN
                  CALL GetConstRealArray( Material, UWrk, &
                       'Material Coordinates Unit Vector 1', GotIt, CurrentElement )
               ELSE IF( i == 2 ) THEN
                  CALL GetConstRealArray( Material, UWrk, &
                       'Material Coordinates Unit Vector 2', GotIt, CurrentElement )
               ELSE                
                  CALL GetConstRealArray( Material, UWrk, &
                       'Material Coordinates Unit Vector 3', GotIt, CurrentElement )
               END IF

               IF( GotIt ) THEN
                  UnitNorm = SQRT( SUM( Uwrk(1:3,1)**2 ) )
                  IF( UnitNorm < EPSILON( UnitNorm ) ) THEN
                     CALL Fatal('ElasticSolve','Given > Materia Coordinate Unit Vector < too short!')
                  END IF
                  TransformMatrix(i,1:3) = Uwrk(1:3,1) / UnitNorm  
                  RotateModuli = .TRUE.
               ELSE 
                  TransformMatrix(i,1:3) = 0.0_dp
                  TransformMatrix(i,i) = 1.0_dp
               END IF
            END DO

            IF( .NOT. RotateModuli  ) THEN
               CALL Fatal( 'ElasticSolve', &
                    'No unit vectors found but > Rotate Elasticity Tensor < set True?' )
            END IF
         END IF


!------------------------------------------------------------------------------
!        Set body forces
!------------------------------------------------------------------------------
         bf_id = ListGetInteger( Model % Bodies(body_id) % Values, &
             'Body Force',gotIt, 1, Model % NumberOFBodyForces)

         LoadVector = 0.0D0
         InertialLoad = 0.0D0

         IF ( gotit ) THEN
           LoadVector(1,1:n) = LoadVector(1,1:n) + ListGetReal( &
            Model % BodyForces(bf_id) % Values, &
                       'Stress Bodyforce 1',n,NodeIndexes,gotIt )

           LoadVector(2,1:n) = LoadVector(2,1:n) + ListGetReal( &
            Model % BodyForces(bf_id) % Values, &
                       'Stress Bodyforce 2',n,NodeIndexes,gotIt )

           IF ( STDOFs > 2 ) THEN
             LoadVector(3,1:n) = LoadVector(3,1:n) + ListGetReal( &
              Model % BodyForces(bf_id) % Values, &
                       'Stress Bodyforce 3',n,NodeIndexes,gotIt )
           END IF

           InertialLoad(1,1:n) = InertialLoad(1,1:n) + ListGetReal( &
            Model % BodyForces(bf_id) % Values, &
                       'Inertial Bodyforce 1',n,NodeIndexes,gotIt )

           InertialLoad(2,1:n) = InertialLoad(2,1:n) + ListGetReal( &
            Model % BodyForces(bf_id) % Values, &
                       'Inertial Bodyforce 2',n,NodeIndexes,gotIt )

           IF ( STDOFs > 2 ) THEN
             InertialLoad(3,1:n) = InertialLoad(3,1:n) + ListGetReal( &
              Model % BodyForces(bf_id) % Values, &
                       'Inertial Bodyforce 3',n,NodeIndexes,gotIt )
           END IF


         END IF

!------------------------------------------------------------------------------
!        Get element local stiffness & mass matrices
!------------------------------------------------------------------------------
         LocalTemperature = 0.0D0
         IF ( ASSOCIATED(TempSol) ) THEN
           DO i=1,n
             k = TempPerm(NodeIndexes(i))
             LocalTemperature(i) = Temperature(k) - ReferenceTemperature(i)
           END DO
         ELSE
           LocalTemperature(1:n) = 0.0d0
         END IF         

         LocalDisplacement = 0.0D0
         DO i=1,n
            k = StressPerm(NodeIndexes(i))
            DO j=1,STDOFs
               LocalDisplacement(j,i) = Displacement(STDOFs*(k-1)+j)
            END DO
         END DO

         IF( LinearModel ) LocalDisplacement = 0.0d0

         IF ( CoordinateSystem == Cartesian ) THEN

            IF (NeoHookeanMaterial) THEN            

               CALL NeoHookeanLocalMatrix( LocalMassMatrix, LocalDampMatrix, &
                    LocalStiffMatrix, LocalForce, LoadVector, InertialLoad, ElasticModulus, &
                    PoissonRatio,Density,Damping,PlaneStress,HeatExpansionCoeff, &
                    LocalTemperature,CurrentElement,n,ElementNodes,LocalDisplacement )

            ELSE
               CALL LocalMatrix( LocalMassMatrix, LocalDampMatrix, &
                    LocalStiffMatrix,LocalForce, LoadVector, InertialLoad, ElasticModulus, &
                    PoissonRatio,Density,Damping,PlaneStress,HeatExpansionCoeff, &
                    LocalTemperature,CurrentElement,n,ElementNodes,LocalDisplacement, &
                    Isotropic, RotateModuli, TransformMatrix)
            END IF
         ELSE
            CALL StressGeneralCompose( LocalMassMatrix, LocalDampMatrix, &
              LocalStiffMatrix,LocalForce, LoadVector, ElasticModulus, &
                PoissonRatio,Density,Damping,PlaneStress,HeatExpansionCoeff, &
                LocalTemperature,CurrentElement,n,ElementNodes,LocalDisplacement )
         END IF
         

!------------------------------------------------------------------------------
!        If time dependent simulation, add mass matrix to global 
!        matrix and global RHS vector
!------------------------------------------------------------------------------
         IF ( TransientSimulation .AND. .NOT. EigenOrHarmonicAnalysis()) THEN
!
!           get the solution from previous iteration for nodes of this element
!------------------------------------------------------------------------------
!          NOTE: the following will replace LocalStiffMatrix and LocalForce
!          with the combined information
!------------------------------------------------------------------------------
              CALL Default2ndOrderTime( LocalMassMatrix, LocalDampMatrix, &
                LocalStiffMatrix, LocalForce )

         END IF
!------------------------------------------------------------------------------
!        Update global matrices from local matrices 
!------------------------------------------------------------------------------

         CALL DefaultUpdateEquations( LocalStiffMatrix, LocalForce )

         IF ( EigenOrHarmonicAnalysis() ) THEN
            CALL DefaultUpdateMass( LocalMassMatrix )
            CALL DefaultUpdateDamp( LocalDampMatrix )
         END IF
!------------------------------------------------------------------------------
      END DO


      CALL DefaultFinishBulkAssembly()
      CALL Info( 'ElasticSolve', 'Assembly done', Level=5 )

!------------------------------------------------------------------------------
!     Neumann & Newton boundary conditions
!------------------------------------------------------------------------------
      DO t = Mesh % NumberOfBulkElements+1, &
             Mesh % NumberOfBulkElements + &
             Mesh % NumberOfBoundaryElements

        CurrentElement => Mesh % Elements(t)

!------------------------------------------------------------------------------
!        Set also the current element pointer in the model structure to
!        reflect the element being processed
!------------------------------------------------------------------------------
        Model % CurrentElement => Mesh % Elements(t)
!------------------------------------------------------------------------------
        n = CurrentElement % TYPE % NumberOfNodes
        NodeIndexes => CurrentElement % NodeIndexes

        IF ( ANY( StressPerm( NodeIndexes ) <= 0 ) ) CYCLE
!
!       The element type 101 (point element) can only be used
!       to set Dirichlet BCs, so skip ´em.
!
        IF ( CurrentElement % TYPE % ElementCode /= 101 ) THEN

        ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
        ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
        ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)

        DO i=1,Model % NumberOfBCs
          IF ( CurrentElement % BoundaryInfo % Constraint == &
                   Model % BCs(i) % Tag ) THEN
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
            LoadVector = 0.0D0
            Alpha      = 0.0D0
            Beta       = 0.0D0
!------------------------------------------------------------------------------
!           Force in given direction BC: \tau\cdot n = F
!------------------------------------------------------------------------------
            GotForceBC = .FALSE.
            LoadVector(1,1:n) =  ListGetReal( Model % BCs(i) % Values, &
                      'Force 1',n,NodeIndexes,gotIt )
            GotForceBC = GotForceBC.OR.gotIt

            LoadVector(2,1:n) =  ListGetReal( Model % BCs(i) % Values, &
                      'Force 2',n,NodeIndexes,gotIt )
            GotForceBC = GotForceBC.OR.gotIt

            LoadVector(3,1:n) =  ListGetReal( Model % BCs(i) % Values, &
                      'Force 3',n,NodeIndexes,gotIt )
            GotForceBC = GotForceBC.OR.gotIt

            Beta(1:n) =  ListGetReal( Model % BCs(i) % Values, &
                      'Normal Force',n,NodeIndexes,gotIt )
            GotForceBC = GotForceBC.OR.gotIt

            GotForceBC = GotForceBC .OR. ListGetLogical( &
                  Model % BCs(i) % Values, 'Force BC', GotIt )

            GotForceBC = GotForceBC .OR. ListGetLogical( &
                  Model % BCs(i) % Values, 'FSI BC', GotIt )

            IF ( .NOT.GotForceBC ) CYCLE

!------------------------------------------------------------------------------

           ParentElement => CurrentElement % BoundaryInfo % Left

           IF ( .NOT. ASSOCIATED( ParentElement ) ) THEN
             ParentElement => CurrentElement % BoundaryInfo % Right
           ELSE
             IF ( ANY(StressPerm(ParentElement % NodeIndexes)==0 )) &
               ParentElement => CurrentElement % BoundaryInfo % Right
           END IF

           k = ParentElement % TYPE % NumberOfNodes
           AdjacentNodes => ParentElement % NodeIndexes

           CALL GetElementNodes( ParentNodes, ParentElement )

           LocalDisplacement = 0.0D0
           IF( .NOT. LinearModel ) THEN
             DO l=1,ParentElement % TYPE % NumberOfNodes
                k = StressPerm(AdjacentNodes(l))
                DO j=1,STDOFs
                  LocalDisplacement(j,l) = Displacement(STDOFs*(k-1)+j)
                END DO
             END DO
            END IF

           NULLIFY( FlowElement )
           FlowNOFNodes = 1

           IF ( ASSOCIATED( FlowSol  ) ) THEN
             FlowElement => CurrentElement % BoundaryInfo % Left

             IF ( .NOT. ASSOCIATED(FlowElement) ) THEN
               FlowElement => CurrentElement % BoundaryInfo % Right
             ELSE
               IF ( ANY(FlowPerm(FlowElement % NodeIndexes)==0 )) THEN
                 FlowElement => CurrentElement % BoundaryInfo % Right
               END IF
             END IF

             IF ( ASSOCIATED(FlowElement) ) THEN
                FlowNOFNodes = 0
                FlowNOFNodes = FlowElement % TYPE % NumberOfNodes
                AdjacentNodes => FlowElement % NodeIndexes
                
                CALL GetElementNodes( FlowNodes, FlowElement )
                
                DO j=1,FlowNOFNodes
                   k = StressPerm(AdjacentNodes(j))
                   IF ( k /= 0 ) THEN
                      k = STDOFs*(k-1)
                      FlowNodes % x(j) = FlowNodes % x(j) + PrevSOL( k+1 )
                      
                      IF ( STDOFs > 1 ) &
                           FlowNodes % y(j) = FlowNodes % y(j) + PrevSOL( k+2 )
                      
                      IF ( STDOFs > 2 ) &
                           FlowNodes % z(j) = FlowNodes % z(j) + PrevSOL( k+3 )
                   END IF
                END DO
                
                Velocity = 0.0D0
                DO l=1,FlowNOFNodes
                   k = FlowPerm(AdjacentNodes(l))
                   DO j=1,FlowSol % DOFs-1
                      Velocity(j,l) = FlowSolution(FlowSol % DOFs*(k-1)+j)
                   END DO
                   Pressure(l) = FlowSolution(FlowSol % DOFs*k)
                END DO
                
                j = ListGetInteger( Model % Bodies(FlowElement % BodyId) &
                      % Values,'Material', minv=1, maxv=Model % NumberOFMaterials )
                Material => Model % Materials(j) % Values
                Viscosity(1:FlowNOFNodes) = ListGetReal( &
                     Material,'Viscosity',FlowNOFNodes,AdjacentNodes,gotIt )

                CompressibilityFlag = ListGetString( Material, &
                     'Compressibility Model', GotIt )

                CompressibilityDefined = .FALSE.
                IF ( GotIt ) THEN
                   IF ( CompressibilityFlag /= 'incompressible' ) THEN
                      CompressibilityDefined = .TRUE.
                   END IF
                END IF

             END IF
             
          END IF

           IF ( CoordinateSystem == Cartesian ) THEN
             CALL LocalBoundaryMatrix( LocalStiffMatrix,LocalForce, LoadVector,   &
              Alpha,Beta,LocalDisplacement, CurrentElement,n,ElementNodes,   &
               ParentElement, ParentElement % TYPE % NumberOfNodes,          &
                ParentNodes, FlowElement, FlowNOFNodes, FlowNodes,Velocity,  &
                 Pressure,Viscosity,Density,CompressibilityDefined )

           ELSE
             CALL StressGeneralBoundary( LocalStiffMatrix,LocalForce, LoadVector,   &
              Alpha,Beta,LocalDisplacement, CurrentElement,n,ElementNodes,   &
               ParentElement, ParentElement % TYPE % NumberOfNodes,          &
                ParentNodes, FlowElement, FlowNOFNodes, FlowNodes,Velocity,  &
                 Pressure,Viscosity,Density,CompressibilityDefined )
           END IF

!------------------------------------------------------------------------------
!           Update global matrices from local matrices (will also affect
!           LocalStiffMatrix and LocalForce if transientsimulation is on).
!------------------------------------------------------------------------------

            IF ( TransientSimulation .AND. .NOT.EigenOrHarmonicAnalysis()) THEN
               LocalDampMatrix = 0._dp
               LocalMassMatrix = 0._dp

               CALL Default2ndOrderTime( LocalMassMatrix, LocalDampMatrix, &
                       LocalStiffMatrix, LocalForce )
            END IF

            CALL DefaultUpdateEquations( LocalStiffMatrix, LocalForce )
!------------------------------------------------------------------------------
          END IF
        END DO
        END IF
      END DO
!------------------------------------------------------------------------------

      CALL DefaultFinishAssembly()
      CALL DefaultDirichletBCs()

!------------------------------------------------------------------------------

      CALL Info( 'ElasticSolve', 'BCs are now set', Level=5 )

!------------------------------------------------------------------------------
!     Solve the system and check for convergence
!------------------------------------------------------------------------------

      UNorm = DefaultSolve()
      RelativeChange = Solver % Variable % NonlinChange

      WRITE( Message, * ) 'Result Norm   : ',UNorm
      CALL Info( 'ElasticSolve', Message, Level=4 )
      WRITE( Message, * ) 'Relative Change : ',RelativeChange
      CALL Info( 'ElasticSolve', Message, Level=4 )

!-----------------------------------------------------------------------------

      IF ( Solver % Variable % NonlinConverged == 1 ) EXIT

!------------------------------------------------------------------------------
    END DO ! of nonlinear iter
!------------------------------------------------------------------------------


!-----------------------------------------------------------------------------
!   Perform strain and stress computation...
!-----------------------------------------------------------------------------
    IF (CalculateStrains .OR. CalcStressAll) THEN
      CALL Info('ElasticSolve','Computing postprocessing fields')
       IF (CalculateStrains) THEN
          Var => VariableGet( Solver % Mesh % Variables, 'Strain', .TRUE. )
          NodalStrain => Var % Values
          IF(CalcPrincipalAll) THEN
             Var => VariableGet( Solver % Mesh % Variables, 'Principal Strain', .TRUE. )
             PrincipalStrain => Var % Values
          END IF
       END IF

       IF (CalcStressAll) THEN
          Var => VariableGet( Solver % Mesh % Variables, 'Stress', .TRUE. )
          NodalStress => Var % Values
       END IF       
      
       CALL ComputeStressAndStrain( Displacement, NodalStrain, NodalStress, VonMises, StressPerm, &
            CalculateStrains, CalcStressAll, NeoHookeanMaterial, PrincipalStress, &
            PrincipalStrain, Tresca, PrincipalAngle)

    END IF


    IF ( ListGetLogical(SolverParams, 'Adaptive Mesh Refinement', GotIt) ) THEN
       CALL RefineMesh( Model, Solver, Displacement, StressPerm, &
            ElastInsideResidual, ElastEdgeResidual, ElastBoundaryResidual )

       IF ( MeshDisplacementActive ) THEN
         StressSol => Solver % Variable
         IF ( .NOT.ASSOCIATED( Mesh, Model % Mesh ) ) &
            CALL DisplaceMesh( Mesh, StressSol % Values, 1, &
                  StressSol % Perm, StressSol % DOFs, .FALSE. )
       END IF
    END IF
    
    IF ( MeshDisplacementActive ) THEN
      CALL Info('ElasticSolve','Displacing the mesh with computed displacement field')
      CALL DisplaceMesh( Model % Mesh, Displacement, 1, &
                StressPerm, STDOFs, .FALSE. )
    END IF

    DEALLOCATE( PrevSOL )

    CALL Info('ElasticSolver','All done',Level=4)
    CALL Info('ElasticSolver','------------------------------------------',Level=4)

!------------------------------------------------------------------------------



    CONTAINS

      
      FUNCTION ElasticityGaussPoints( Element ) RESULT ( N_gauss ) 

        TYPE(Element_t) :: Element
        INTEGER :: N_gauss
        
        INTEGER :: ElemFamily

        ElemFamily = Element % TYPE % ElementCode / 100
        N_gauss = 0

        SELECT CASE( ElemFamily ) 

!       Line segments:
!       --------------
        CASE( 2 )
          SELECT CASE( n )
          CASE( 2 )
            N_gauss = 1
          CASE( 3 )
            N_gauss = 4
          CASE( 4 )
            N_gauss = 5
          END SELECT
          
!       Triangles:
!       ----------
        CASE( 3 )
          SELECT CASE( n )
          CASE( 3 )
            N_gauss = 1
          CASE( 6 )
            N_gauss = 7
          CASE( 10 )
            N_gauss = 17
          END SELECT

!       Quadrilaterals:
!       ---------------
        CASE( 4 )
          SELECT CASE( n )
          CASE( 4 )
            N_gauss = 4
          CASE( 8,9 )
            N_gauss = 16
          CASE( 12,16 )
            N_gauss = 25
          END SELECT
          
!       Tetrahedrons:
!       -------------
        CASE( 5 )
          SELECT CASE( n )
          CASE( 4 )
            N_gauss = 1
          CASE( 10 )
            N_gauss = 11
          END SELECT

!       Octahedrons:
!       ------------
        CASE( 8 )
          SELECT CASE( n )
          CASE( 8 )
            N_gauss = 8
          CASE( 20,27 )
            N_gauss = 64
          END SELECT
       
!       Others:
!       -------
        CASE DEFAULT
           !CALL Fatal( 'ElasticSolve',  'Unknown element type.' )
           N_gauss = 0
        END SELECT

        !IF( N_gauss == 0 ) THEN
        !  CALL Fatal( 'ElasticSolve',  'Unknown number of nodes.' )
        !END IF

      END FUNCTION ElasticityGaussPoints



!------------------------------------------------------------------------------
   SUBROUTINE LocalMatrix( MassMatrix,DampMatrix,StiffMatrix,ForceVector, &
        LoadVector, InertialLoad, ElasticModulus, NodalPoisson, NodalDensity, NodalDamping, &
        PlaneStress,NodalHeatExpansion, NodalTemperature, Element,n,Nodes, &
        NodalDisplacement, Isotropic, RotateModuli, TransformMatrix )
!------------------------------------------------------------------------------

     REAL(KIND=dp) :: StiffMatrix(:,:),MassMatrix(:,:),DampMatrix(:,:), &
          NodalHeatExpansion(:,:,:), ElasticModulus(:,:,:)
     REAL(KIND=dp) :: NodalTemperature(:),NodalDensity(:), &
                NodalDamping(:),LoadVector(:,:), InertialLoad(:,:)
     REAL(KIND=dp) :: NodalDisplacement(:,:), TransformMatrix(3,3)
     REAL(KIND=dp), DIMENSION(:) :: ForceVector, NodalPoisson

     LOGICAL :: PlaneStress, Isotropic, RotateModuli

     TYPE(Element_t) :: Element
     TYPE(Nodes_t) :: Nodes

     INTEGER :: n, N_gauss
!------------------------------------------------------------------------------
!
     REAL(KIND=dp) :: Basis(n)
     REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric

     REAL(KIND=dp) :: Force(3), InertialForce(3), NodalLame1(n),NodalLame2(n),Density, &
          Damping,Lame1,Lame2
     REAL(KIND=dp) :: Grad(3,3),Identity(3,3),DetDefG,CofG(3,3),TrueForce(3), G(6,6)
     REAL(KIND=dp) ::  DefG(3,3), Strain(3,3), Stress2(3,3), Stress1(3,3)

     REAL(KIND=dp) :: dDefG(3,3),dStrain(3,3),dStress2(3,3),dStress1(3,3)
     REAL(KIND=dp) :: dDefGU(3,3),dStrainU(3,3),dStress2U(3,3),dStress1U(3,3)

     REAL(KIND=dp) :: Load(3),Temperature, GradBasis(3,3)
     REAL(KIND=dp), DIMENSION(3,3) :: HeatExpansion

     INTEGER :: i,j,k,l,p,q,t,dim

     REAL(KIND=dp) :: s,u,v,w
  
     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     INTEGER :: N_Integ

     REAL(KIND=dp), DIMENSION(:), POINTER :: U_Integ,V_Integ,W_Integ,S_Integ

     LOGICAL :: stat
!------------------------------------------------------------------------------

     dim = CoordinateSystemDimension()

     IF (Isotropic) THEN 
        IF ( PlaneStress ) THEN
           NodalLame1(1:n) = ElasticModulus(1,1,1:n) * NodalPoisson(1:n) /  &
                ( (1.0d0 - NodalPoisson(1:n)**2) )
        ELSE
           NodalLame1(1:n) = ElasticModulus(1,1,1:n) * NodalPoisson(1:n) /  &
                (  (1.0d0 + NodalPoisson(1:n)) * (1.0d0 - 2.0d0*NodalPoisson(1:n)) )
        END IF

        NodalLame2(1:n) = ElasticModulus(1,1,1:n)  / ( 2* (1.0d0 + NodalPoisson(1:n)) )
     END IF



     ForceVector = 0.0D0
     StiffMatrix = 0.0D0
     MassMatrix  = 0.0D0
     DampMatrix  = 0.0d0

     Identity = 0.0D0
     DO i = 1,dim
        Identity(i,i) = 1.0D0
     END DO
!    
!    Integration stuff
!    

     N_gauss = ElasticityGaussPoints( Element )
     IF (N_gauss > 0) THEN
        IntegStuff = GaussPoints( element,N_gauss )
     ELSE
        IntegStuff = GaussPoints( element )
     END IF

     U_Integ => IntegStuff % u
     V_Integ => IntegStuff % v
     W_Integ => IntegStuff % w
     S_Integ => IntegStuff % s
     N_Integ =  IntegStuff % n
!
!   Now we start integrating
!
    DO t=1,N_Integ

      u = U_Integ(t)
      v = V_Integ(t)
      w = W_Integ(t)

!------------------------------------------------------------------------------
!     Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
                 Basis,dBasisdx )

      s = SqrtElementMetric * S_Integ(t)

!------------------------------------------------------------------------------
!  
!     Force at integration point
!   
      Force = 0.0D0
      DO i=1,dim
        Force(i) = SUM( LoadVector(i,1:n)*Basis )
        InertialForce(i) = SUM( InertialLoad(i,1:n)*Basis )
      END DO

      IF (Isotropic) THEN
         !-------------------------------------------------
         ! Lame parameters at the integration point
         !------------------------------------------------
         Lame1 = SUM( NodalLame1(1:n)*Basis )
         Lame2 = SUM( NodalLame2(1:n)*Basis )
         Density = SUM( NodalDensity(1:n)*Basis )
         Damping = SUM( NodalDamping(1:n)*Basis )

         !------------------------------------------------------------------
         ! Deformation gradient etc. evaluated using the current solution:
         !------------------------------------------------------------------
         Grad = MATMUL(NodalDisplacement(:,1:n),dBasisdx)
         DefG = Identity + Grad
         Strain = (TRANSPOSE(Grad)+Grad+MATMUL(TRANSPOSE(Grad),Grad))/2.0D0
         Stress2 = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,dim)*Identity
         Stress1 = MATMUL(DefG,Stress2)

         SELECT CASE( dim )
         CASE( 1 )
            DetDefG = DefG(1,1)
         CASE( 2 )
            DetDefG = DefG(1,1)*DefG(2,2) - DefG(1,2)*DefG(2,1)
         CASE( 3 )
            DetDefG = DefG(1,1) * ( DefG(2,2)*DefG(3,3) - DefG(2,3)*DefG(3,2) ) + &
                 DefG(1,2) * ( DefG(2,3)*DefG(3,1) - DefG(2,1)*DefG(3,3) ) + &
                 DefG(1,3) * ( DefG(2,1)*DefG(3,2) - DefG(2,2)*DefG(3,1) )
         END SELECT

         !-----------------------------------------------------------------------
         !  Gateaux derivatives of the solution with respect to the displacement:
         !  ---------------------------------------------------------------------
         dDefGU = Grad
         dStrainU = (MATMUL(TRANSPOSE(DefG),dDefGU) &
              + MATMUL(TRANSPOSE(dDefGU),DefG))/2.0D0
         dStress2U = 2.0D0*Lame2*dStrainU + Lame1*TRACE(dStrainU,dim)*Identity
         dStress1U = MATMUL(dDefGU,Stress2) + MATMUL(DefG,dStress2U)

         !----------------------------------------------------------------------------
         ! Loop over the test functions (stiffness matrix for Newton linearization):
         ! ---------------------------------------------------------------------------
         DO p = 1,N
            DO i = 1,dim
               !------------------------------------------------------------------------
               !  Gateaux derivatives of the solution with respect to the test functions:
               ! -----------------------------------------------------------------------
               dDefG = 0.0D0; dDefG(i,:) = dBasisdx(p,:)
               dStrain = (MATMUL(TRANSPOSE(DefG),dDefG) &
                    + MATMUL(TRANSPOSE(dDefG),DefG))/2.0D0
               dStress2 = 2.0D0*Lame2*dStrain + Lame1*TRACE(dStrain,dim)*Identity
               dStress1 = MATMUL(dDefG,Stress2) + MATMUL(DefG,dStress2)

               ForceVector(dim*(p-1)+i) = ForceVector(dim*(p-1)+i) &
                    +(Basis(p)*Force(i)*DetDefG &
                    +Basis(p)*InertialForce(i)*Density &
                    -DOT_PRODUCT(dBasisdx(p,:),Stress1(i,:)) &
                    +DOT_PRODUCT(dBasisdx(p,:),dStress1U(i,:)))*s

               !---------------------------------
               ! Loop over the basis functions:
               ! --------------------------------
               DO q = 1,N
                  DO j = 1,dim

                     GradBasis = 0.0D0; GradBasis(j,:) = dBasisdx(q,:)

                     StiffMatrix(dim*(p-1)+i,dim*(q-1)+j) &
                          = StiffMatrix(dim*(p-1)+i,dim*(q-1)+j) &
                          + DOT_PRODUCT(dBasisdx(q,:),dStress1(j,:))*s

                  END DO
               END DO
            END DO
         END DO

      ELSE
         ! print *, 'anisotropy active...'
         !--------------------------------------------------------------------------
         ! Anisotropic material is handled in this branch. 
         !-------------------------------------------------------------------------
         IF (dim /= 3 ) &
              CALL Fatal( 'ElasticSolve',  'Material anistropy implemented only for 3-d' )

         G = 0.0d0
         DO i=1,SIZE(ElasticModulus,1)
            DO j=1,SIZE(ElasticModulus,2)
               G(i,j) = SUM( Basis(1:n) * ElasticModulus(i,j,1:n) )
            END DO
         END DO

         IF ( RotateModuli ) THEN
            CALL RotateElasticityMatrix( G, TransformMatrix, dim )
         END IF
            
         !-------------------------------------------------------------------------
         ! Compute the formulation variables for the current solution iterate
         !--------------------------------------------------------------------
         Grad = MATMUL(NodalDisplacement(:,1:n),dBasisdx)
         DefG = Identity + Grad
         Strain = (TRANSPOSE(Grad)+Grad+MATMUL(TRANSPOSE(Grad),Grad))/2.0D0

         SELECT CASE( dim )
         CASE( 1 )
            DetDefG = DefG(1,1)
         CASE( 2 )
            DetDefG = DefG(1,1)*DefG(2,2) - DefG(1,2)*DefG(2,1)
         CASE( 3 )
            DetDefG = DefG(1,1) * ( DefG(2,2)*DefG(3,3) - DefG(2,3)*DefG(3,2) ) + &
                 DefG(1,2) * ( DefG(2,3)*DefG(3,1) - DefG(2,1)*DefG(3,3) ) + &
                 DefG(1,3) * ( DefG(2,1)*DefG(3,2) - DefG(2,2)*DefG(3,1) )
         END SELECT

         !-------------------------------------------------------------
         ! The second Piola-Kirchhoff stress for the current iterate
         !--------------------------------------------------------------
         CALL Strain2Stress(Stress2, Strain, G, dim, .FALSE.)         
         !--------------------------------------------------
         ! The first Piola-Kirchhoff stress
         !--------------------------------------------------
         Stress1 = MATMUL(DefG,Stress2)

         !-----------------------------------------------------------------
         ! dStress2U will be the derivative term Dg(F_k)[grad u_k] with
         ! g the response function giving the second Piola-Kirchhoff stress
         ! in terms of the deformation gradient F
         !------------------------------------------------------------------
         dDefGU = Grad
         dStrainU = (MATMUL(TRANSPOSE(DefG),Grad) &
              + MATMUL(TRANSPOSE(Grad),DefG))/2.0D0
         CALL Strain2Stress(dStress2U, dStrainU, G, dim, .FALSE.)    
         !-------------------------------------------------------------
         ! dStress1U presents the derivative term DS(F_k)[grad u_k] with
         ! S the first  Piola-Kirchhoff stress
         !-------------------------------------------------------------
         dStress1U = MATMUL(Grad,Stress2) + MATMUL(DefG,dStress2U)

         !---------------------------------------------------------
         ! Newton iteration:
         !------------------------------------------------
         DO p = 1,N
            DO i = 1,dim
               !------------------------------------------------------------------------
               ! Grad will now be the velocity gradient corresponding to the velocity
               ! test function
               ! -----------------------------------------------------------------------
               Grad = 0.0d0
               Grad(i,:) = dBasisdx(p,:)

               !---------------------------------------------------------------------
               ! dStress2 will correspond to the term (G*)dStrainU, with G* the adjoint
               ! of the elasticity tensor and the strain field dStrainU defined as 
               ! follows: 
               !------------------------------------------------------------------
               dStrainU = (MATMUL(TRANSPOSE(DefG),Grad) &
                    + MATMUL(TRANSPOSE(Grad),DefG))/2.0D0
               CALL Strain2Stress(dStress2, dStrainU, TRANSPOSE(G), dim, .FALSE.)                  

               !-------------------------------------------------------------
               ! Then dStress1 relates to having an equivalent expression for
               ! the derivative DS(F_k)[grad u_{k+1}] with S the first  
               ! Piola-Kirchhoff stress.
               !-------------------------------------------------------------
               dStress1 = MATMUL(Grad,Stress2) + MATMUL(DefG,dStress2)

               ForceVector(dim*(p-1)+i) = ForceVector(dim*(p-1)+i) &
                    +(Basis(p)*Force(i)*DetDefG &
                    +Basis(p)*InertialForce(i)*Density &
                    -DOT_PRODUCT(dBasisdx(p,:),Stress1(i,:)) &
                    +DOT_PRODUCT(dBasisdx(p,:),dStress1U(i,:)))*s

               DO q = 1,N
                  DO j = 1,dim
                     StiffMatrix(dim*(p-1)+i,dim*(q-1)+j) &
                          = StiffMatrix(dim*(p-1)+i,dim*(q-1)+j) &
                          + DOT_PRODUCT(dBasisdx(q,:),dStress1(j,:))*s
                  END DO
               END DO
            END DO
         END DO
      END IF


!      Integrate mass matrix:
!      ----------------------
       DO p = 1,N
          DO q = 1,N
             DO i = 1,dim

                MassMatrix(dim*(p-1)+i,dim*(q-1)+i) &
                        = MassMatrix(dim*(p-1)+i,dim*(q-1)+i) &
                        + Basis(p)*Basis(q)*Density*s

             END DO
          END DO
       END DO

!      Utilize the Rayleigh damping:
!      -----------------------------
       DampMatrix = Damping * MassMatrix

    END DO

!------------------------------------------------------------------------------

  END SUBROUTINE LocalMatrix
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE NeoHookeanLocalMatrix( MassMatrix,DampMatrix,StiffMatrix,ForceVector, &
       LoadVector, InertialLoad, NodalYoung, NodalPoisson, NodalDensity, NodalDamping, &
       PlaneStress,NodalHeatExpansion, NodalTemperature, Element,n,Nodes, &
       NodalDisplacement )
!------------------------------------------------------------------------------
    
    REAL(KIND=dp) :: StiffMatrix(:,:),MassMatrix(:,:),DampMatrix(:,:), &
         NodalHeatExpansion(:,:,:), NodalYoung(:,:,:)
    REAL(KIND=dp) :: NodalTemperature(:),NodalDensity(:), &
         NodalDamping(:),LoadVector(:,:), InertialLoad(:,:)
    REAL(KIND=dp) :: NodalDisplacement(:,:)
    REAL(KIND=dp), DIMENSION(:) :: ForceVector,NodalPoisson

    LOGICAL :: PlaneStress

    TYPE(Element_t) :: Element
    TYPE(Nodes_t) :: Nodes

    INTEGER :: n, N_gauss
    !------------------------------------------------------------------------------
    !
    REAL(KIND=dp) :: Basis(n)
    REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric

    REAL(KIND=dp) :: Force(3), InertialForce(3), NodalLame1(n),NodalLame2(n),Density, &
         Damping,Lame1,Lame2
    REAL(KIND=dp) :: Grad(3,3),InvC(3,3),Identity(3,3),DetDefG,CofG(3,3),TrueForce(3)
    REAL(KIND=dp) ::  DefG(3,3), InvDefG(3,3),Strain(3,3), Stress2(3,3), Stress1(3,3)
    REAL(KIND=dp) :: dDefG(3,3),dStrain(3,3),dStress2(3,3),dStress1(3,3)
    REAL(KIND=dp) :: dDefGU(3,3),dStrainU(3,3),dStress2U(3,3),dStress1U(3,3)

    REAL(KIND=dp) :: Load(3),Temperature, GradBasis(3,3)
    REAL(KIND=dp), DIMENSION(3,3) :: HeatExpansion

    INTEGER :: i,j,k,l,p,q,t,dim

    REAL(KIND=dp) :: s,u,v,w

    TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

    INTEGER :: N_Integ

    REAL(KIND=dp), DIMENSION(:), POINTER :: U_Integ,V_Integ,W_Integ,S_Integ

    LOGICAL :: stat
    !------------------------------------------------------------------------------

    dim = CoordinateSystemDimension()

    IF ( PlaneStress ) THEN
       NodalLame1(1:n) = NodalYoung(1,1,1:n) * NodalPoisson(1:n) /  &
            ( (1.0d0 - NodalPoisson(1:n)**2) )
    ELSE
       NodalLame1(1:n) = NodalYoung(1,1,1:n) * NodalPoisson(1:n) /  &
            (  (1.0d0 + NodalPoisson(1:n)) * (1.0d0 - 2.0d0*NodalPoisson(1:n)) )
    END IF

    NodalLame2(1:n) = NodalYoung(1,1,1:n)  / ( 2* (1.0d0 + NodalPoisson(1:n)) )

    ForceVector = 0.0D0
    StiffMatrix = 0.0D0
    MassMatrix  = 0.0D0
    DampMatrix  = 0.0d0

    Identity = 0.0D0
    DO i = 1,dim
       Identity(i,i) = 1.0D0
    END DO
    !    
    !    Integration stuff
    !    

    N_gauss = ElasticityGaussPoints( Element )
    IF (N_gauss > 0) THEN
       IntegStuff = GaussPoints( element,N_gauss )
    ELSE
       IntegStuff = GaussPoints( element )
    END IF


    U_Integ => IntegStuff % u
    V_Integ => IntegStuff % v
    W_Integ => IntegStuff % w
    S_Integ => IntegStuff % s
    N_Integ =  IntegStuff % n
    !
    !   Now we start integrating
    !
    DO t=1,N_Integ

       u = U_Integ(t)
       v = V_Integ(t)
       w = W_Integ(t)

       !------------------------------------------------------------------------------
       !     Basis function values & derivatives at the integration point
       !------------------------------------------------------------------------------
       stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
            Basis,dBasisdx )

       s = SqrtElementMetric * S_Integ(t)

       !------------------------------------------------------------------------------
       !  
       !     Force at integration point
       !   
       Force = 0.0D0
       DO i=1,dim
          Force(i) = SUM( LoadVector(i,1:n)*Basis )
          InertialForce(i) = SUM( InertialLoad(i,1:n)*Basis )
       END DO
       !
       !     Lame parameters at the integration point
       !
       Lame1 = SUM( NodalLame1(1:n)*Basis )
       Lame2 = SUM( NodalLame2(1:n)*Basis )
       Density = SUM( NodalDensity(1:n)*Basis )
       Damping = SUM( NodalDamping(1:n)*Basis )
       
      
       !--------------------------------------------------------------------
       ! Compute the formulation variables for the current solution iterate
       !--------------------------------------------------------------------
       Grad = MATMUL(NodalDisplacement(:,1:n),dBasisdx)
       DefG = Identity + Grad

       SELECT CASE( dim )
       CASE( 1 )
          DetDefG = DefG(1,1)
       CASE( 2 )
          DetDefG = DefG(1,1)*DefG(2,2) - DefG(1,2)*DefG(2,1)
       CASE( 3 )
          DetDefG = DefG(1,1) * ( DefG(2,2)*DefG(3,3) - DefG(2,3)*DefG(3,2) ) + &
               DefG(1,2) * ( DefG(2,3)*DefG(3,1) - DefG(2,1)*DefG(3,3) ) + &
               DefG(1,3) * ( DefG(2,1)*DefG(3,2) - DefG(2,2)*DefG(3,1) )
       END SELECT

       InvC = MATMUL( TRANSPOSE(DefG), DefG )
       InvDefG = DefG
       !-------------------------------------------------------------
       !  InvC will now be the inverse of the right Cauchy-Green tensor
       !-------------------------------------------------------------
       CALL InvertMatrix( InvC, dim )
       CALL InvertMatrix( InvDefG, dim )       
       !-------------------------------------------------------------
       ! The second Piola-Kirchhoff stress for the current iterate
       !--------------------------------------------------------------
       Stress2 = Lame1/2.0d0 * (DetDefG - 1.0d0) * (DetDefG + 1.0d0) * InvC + &
            Lame2 * (Identity - InvC)
       !--------------------------------------------------
       ! The first Piola-Kirchhoff stress
       !--------------------------------------------------
       Stress1 = MATMUL(DefG,Stress2)

       !-----------------------------------------------------------------
       ! dStress2U gives the derivative term DG(F_k)[grad u_k] with
       ! G the response function giving the second Piola-Kirchhoff stress
       ! in terms of the deformation gradient F
       !------------------------------------------------------------------
       dStress2U =  Lame1 * DetDefG**2 * TRACE( MATMUL(Grad,InvDefG), dim ) * InvC - &
            Lame1/2.0d0 * (DetDefG - 1.0d0) * (DetDefG + 1.0d0) * &
            MATMUL( InvC, & 
            MATMUL( MATMUL(TRANSPOSE(DefG),Grad) + MATMUL(TRANSPOSE(Grad),DefG), InvC) ) + & 
            Lame2 * MATMUL( InvC, & 
            MATMUL( MATMUL(TRANSPOSE(DefG),Grad) + MATMUL(TRANSPOSE(Grad),DefG), InvC) )   

       !-------------------------------------------------------------
       ! dStress1U presents the derivative term DS(F_k)[grad u_k] with
       ! S the first  Piola-Kirchhoff stress
       !-------------------------------------------------------------
       dStress1U = MATMUL(Grad,Stress2) + MATMUL(DefG,dStress2U)

       !---------------------------------------------------------
       ! Newton iteration:
       !------------------------------------------------
       DO p = 1,N
          DO i = 1,dim
             !------------------------------------------------------------------------
             ! Grad will now be the velocity gradient corresponding to the velocity
             ! test function
             ! -----------------------------------------------------------------------
             Grad = 0.0d0
             Grad(i,:) = dBasisdx(p,:)

             !-----------------------------------------------------------------
             ! dStress2 gives the derivative term DG(F_k)[grad v] with
             ! G the response function giving the second Piola-Kirchhoff stress
             ! in terms of the deformation gradient F and v the test function
             !------------------------------------------------------------------
             dStress2 = Lame1 * DetDefG**2 * TRACE( MATMUL(Grad,InvDefG), dim ) * InvC - &
                  Lame1/2.0d0 * (DetDefG - 1.0d0) * (DetDefG + 1.0d0) * &
                  MATMUL( InvC, & 
                  MATMUL( MATMUL(TRANSPOSE(DefG),Grad) + MATMUL(TRANSPOSE(Grad),DefG), InvC) ) + & 
                  Lame2 * MATMUL( InvC, & 
                  MATMUL( MATMUL(TRANSPOSE(DefG),Grad) + MATMUL(TRANSPOSE(Grad),DefG), InvC) )  

             !-------------------------------------------------------------
             ! dStress1 is the derivative DS(F_k)[grad v] with
             ! S the first  Piola-Kirchhoff stress      
             !-------------------------------------------------------------
             dStress1 = MATMUL(Grad,Stress2) + MATMUL(DefG,dStress2)
 
             ForceVector(dim*(p-1)+i) = ForceVector(dim*(p-1)+i) &
                  +(Basis(p)*Force(i)*DetDefG &
                  +Basis(p)*InertialForce(i)*Density &
                  -DOT_PRODUCT(dBasisdx(p,:),Stress1(i,:)) &
                  +DOT_PRODUCT(dBasisdx(p,:),dStress1U(i,:)))*s

             DO q = 1,N
                DO j = 1,dim
                   StiffMatrix(dim*(p-1)+i,dim*(q-1)+j) &
                        = StiffMatrix(dim*(p-1)+i,dim*(q-1)+j) &
                        + DOT_PRODUCT(dBasisdx(q,:),dStress1(j,:))*s
                END DO
             END DO
          END DO
       END DO


       !      Integrate mass matrix:
       !      ----------------------
       DO p = 1,N
          DO q = 1,N
             DO i = 1,dim

                MassMatrix(dim*(p-1)+i,dim*(q-1)+i) &
                     = MassMatrix(dim*(p-1)+i,dim*(q-1)+i) &
                     + Basis(p)*Basis(q)*Density*s

             END DO
          END DO
       END DO

       !      Utilize the Rayleigh damping:
       !      -----------------------------
       DampMatrix = Damping * MassMatrix

    END DO

!------------------------------------------------------------------------------
  END SUBROUTINE NeoHookeanLocalMatrix
!------------------------------------------------------------------------------





!------------------------------------------------------------------------------
   SUBROUTINE StressGeneralCompose( MassMatrix,DampMatrix,StiffMatrix,ForceVector, &
        LoadVector, NodalYoung, NodalPoisson, NodalDensity, NodalDamping, &
        PlaneStress,NodalHeatExpansion, NodalTemperature, Element,n,Nodes, &
        NodalDisplacement )
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: StiffMatrix(:,:),MassMatrix(:,:),DampMatrix(:,:), &
          NodalHeatExpansion(:,:,:), NodalYoung(:,:,:)
     REAL(KIND=dp) :: NodalTemperature(:),NodalDensity(:), &
                NodalDamping(:),LoadVector(:,:)
     REAL(KIND=dp) :: NodalDisplacement(:,:)
     REAL(KIND=dp), DIMENSION(:) :: ForceVector,NodalPoisson

     LOGICAL :: PlaneStress

     TYPE(Element_t) :: Element
     TYPE(Nodes_t) :: Nodes

     INTEGER :: n
!------------------------------------------------------------------------------
!
     REAL(KIND=dp) :: Basis(n)
     REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric

     REAL(KIND=dp) :: Force(3),NodalLame1(n),NodalLame2(n),Density, &
          Damping,Lame1,Lame2
     REAL(KIND=dp) :: Grad(3,3),Identity(3,3),DetDefG,CofG(3,3),TrueForce(3)
     REAL(KIND=dp) ::  DefG(3,3), Strain(3,3), Stress2(3,3), Stress1(3,3)
     REAL(KIND=dp) :: dDefG(3,3),dStrain(3,3),dStress2(3,3),dStress1(3,3)
     REAL(KIND=dp) :: dDefGU(3,3),dStrainU(3,3),dStress2U(3,3),dStress1U(3,3)
     REAL(KIND=dp) :: Stress(3,3)

     REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3),X,Y,Z
     REAL(KIND=dp) :: Disp(3)

     REAL(KIND=dp) :: Load(3),Temperature, GradBasis(3,3)
     REAL(KIND=dp), DIMENSION(3,3) :: HeatExpansion

     INTEGER :: i,j,k,l,p,q,t,dim

     REAL(KIND=dp) :: s,u,v,w,Radius
  
     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     INTEGER :: N_Integ, N_gauss

     REAL(KIND=dp), DIMENSION(:), POINTER :: U_Integ,V_Integ,W_Integ,S_Integ

     LOGICAL :: stat, CylindricSymmetry
!------------------------------------------------------------------------------

     CylindricSymmetry = ( CoordinateSystem == CylindricSymmetric .OR. &
          CoordinateSystem == AxisSymmetric )

     IF( CylindricSymmetry ) THEN
       dim = 3
     ELSE
       dim = CoordinateSystemDimension()
     END IF

     IF ( PlaneStress ) THEN
       NodalLame1(1:n) = NodalYoung(1,1,:) * NodalPoisson /  &
            ( (1.0d0 - NodalPoisson**2) )
     ELSE
       NodalLame1(1:n) = NodalYoung(1,1,:) * NodalPoisson /  &
          (  (1.0d0 + NodalPoisson) * (1.0d0 - 2.0d0*NodalPoisson) )
     END IF

     NodalLame2(1:n) = NodalYoung(1,1,:)  / ( 2* (1.0d0 + NodalPoisson) )

     ForceVector = 0.0D0
     StiffMatrix = 0.0D0
     MassMatrix  = 0.0D0
     DampMatrix  = 0.0d0

     Identity = 0.0D0
     DO i = 1,dim
        Identity(i,i) = 1.0D0
     END DO
!    
!    Integration stuff
!    
     N_gauss = ElasticityGaussPoints( Element )
     IF (N_gauss > 0) THEN
        IntegStuff = GaussPoints( element,N_gauss )
     ELSE
        IntegStuff = GaussPoints( element )
     END IF

     U_Integ => IntegStuff % u
     V_Integ => IntegStuff % v
     W_Integ => IntegStuff % w
     S_Integ => IntegStuff % s
     N_Integ =  IntegStuff % n
!
!   Now we start integrating
!
    DO t=1,N_Integ

      u = U_Integ(t)
      v = V_Integ(t)
      w = W_Integ(t)

!------------------------------------------------------------------------------
!     Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
                 Basis,dBasisdx )

      IF( CoordinateSystem /= Cartesian ) THEN
         X = SUM( nodes % x(1:n)*Basis )
         Y = SUM( nodes % y(1:n)*Basis )
         Z = SUM( nodes % z(1:n)*Basis )
      END IF
      Radius = X

      CALL CoordinateSystemInfo( Metric, SqrtMetric, Symb, dSymb, X, Y, Z )

      s = 2.0D0*Pi*Radius*SqrtElementMetric * S_Integ(t)

!------------------------------------------------------------------------------
!  
!     Force at integration point
!   
      Force = 0.0D0
      DO i=1,dim
        Force(i) = SUM( LoadVector(i,1:n)*Basis )
      END DO
!
!     Lame parameters at the integration point
!
      Lame1 = SUM( NodalLame1(1:n)*Basis )
      Lame2 = SUM( NodalLame2(1:n)*Basis )
      Density = SUM( NodalDensity(1:n)*Basis )
      Damping = SUM( NodalDamping(1:n)*Basis )
!
!     Temperature at the integration point

!      Temperature = SUM( NodalTemperature(1:n)*Basis )

!===========================================================================
!
!                       S T I F F N E S S   M A T R I X 
!
!                                    A N D
!
!                   R E S I D U A L   F O R C E   V E C T O R
!
!===========================================================================

!      Loop over the test functions:
!      -----------------------------
       DO p = 1,N
          DO i = 1,2
             Strain = 0.0d0
             Strain(i,1:2) = dBasisdx(p,1:2)
             IF (i.EQ.1) Strain(3,3) = Basis(p)/Radius
             Strain = 0.5d0*(Strain + TRANSPOSE(Strain))
             Stress = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,3)*Identity
             ForceVector(2*(p-1)+i) = ForceVector(2*(p-1)+i)+Basis(p)*Force(i)*s

!            Loop over the basis functions:
!            ------------------------------
             DO q = 1,N
                DO j = 1,2
                   Strain = 0.0d0
                   Strain(j,1:2) = dBasisdx(q,1:2)
                   IF (j.EQ.1) Strain(3,3) = Basis(q)/Radius
                   Strain = 0.5d0*(Strain + TRANSPOSE(Strain))
                   StiffMatrix(2*(p-1)+i,2*(q-1)+j) &
                        = StiffMatrix(2*(p-1)+i,2*(q-1)+j) &
                        + DDOT_PRODUCT(Strain,Stress,3)*s

                END DO
             END DO
          END DO
       END DO

!      Integrate mass matrix:
!      ----------------------
       DO p = 1,N
          DO q = 1,N
             DO i = 1,2
                MassMatrix(2*(p-1)+i,2*(q-1)+i) &
                        = MassMatrix(2*(p-1)+i,2*(q-1)+i) &
                        + Basis(p)*Basis(q)*Density*s

             END DO
          END DO
       END DO

!      Utilize the Rayleigh damping:
!      -----------------------------
       DampMatrix = Damping * MassMatrix

    END DO

!------------------------------------------------------------------------------

  END SUBROUTINE StressGeneralCompose
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
   SUBROUTINE BackStressGeneralCompose( MassMatrix,DampMatrix,StiffMatrix, &
        ForceVector, LoadVector, NodalYoung, NodalPoisson, NodalDensity, &
        NodalDamping, PlaneStress,NodalHeatExpansion, NodalTemperature, &
        Element,n,Nodes, NodalDisplacement )
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: StiffMatrix(:,:),MassMatrix(:,:),DampMatrix(:,:), &
          NodalHeatExpansion(:,:,:)
     REAL(KIND=dp) :: NodalTemperature(:),Density,Damping,LoadVector(:,:)
     REAL(KIND=dp) :: NodalDisplacement(:,:)
     REAL(KIND=dp), DIMENSION(:) :: ForceVector,NodalPoisson,NodalYoung

     LOGICAL :: PlaneStress

     TYPE(Element_t) :: Element
     TYPE(Nodes_t) :: Nodes

     INTEGER :: n, Bound
!------------------------------------------------------------------------------
!
     REAL(KIND=dp) :: Basis(n)
     REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric

     REAL(KIND=dp) :: Force(3),NodalLame1(n),NodalLame2(n),NodalDensity(n), &
          NodalDamping(n),Lame1,Lame2
     REAL(KIND=dp) :: Grad(3,3),Identity(3,3),DetDefG,CofG(3,3),TrueForce(3)
     REAL(KIND=dp) ::  DefG(3,3), Strain(3,3), Stress2(3,3), Stress1(3,3)
     REAL(KIND=dp) :: dDefG(3,3),dStrain(3,3),dStress2(3,3),dStress1(3,3)
     REAL(KIND=dp) :: dDefGU(3,3),dStrainU(3,3),dStress2U(3,3),dStress1U(3,3)

     REAL(KIND=dp) :: Load(3),Temperature, Disp(3), GradBasis(3,3), GradTest(3,3)
     REAL(KIND=dp), DIMENSION(3,3) :: HeatExpansion

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3), Dfrm(3)

     INTEGER :: i,j,k,l,p,q,t,dim,i2,j2,k2,l2

     REAL(KIND=dp) :: s,u,v,w,X,Y,Z
  
     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     INTEGER :: N_Integ

     REAL(KIND=dp), DIMENSION(:), POINTER :: U_Integ,V_Integ,W_Integ,S_Integ

     LOGICAL :: stat, CylindricSymmetry
!------------------------------------------------------------------------------

     CylindricSymmetry = ( CoordinateSystem == CylindricSymmetric .OR. &
          CoordinateSystem == AxisSymmetric )

     IF ( CylindricSymmetry ) THEN
        dim = 3
     ELSE
        dim = CoordinateSystemDimension()
     END IF

     IF ( PlaneStress ) THEN
       NodalLame1(1:n) = NodalYoung * NodalPoisson /  &
            ( (1.0d0 - NodalPoisson**2) )
     ELSE
       NodalLame1(1:n) = NodalYoung * NodalPoisson /  &
          (  (1.0d0 + NodalPoisson) * (1.0d0 - 2.0d0*NodalPoisson) )
     END IF

     NodalLame2(1:n) = NodalYoung  / ( 2* (1.0d0 + NodalPoisson) )

     ForceVector = 0.0D0
     StiffMatrix = 0.0D0
     MassMatrix  = 0.0D0
     DampMatrix  = 0.0D0

     Identity = 0.0D0
     DO i = 1,dim
        Identity(i,i) = 1.0D0
     END DO
!    
!    Integration stuff
!    
     SELECT CASE(Element % TYPE % ElementCode/100)

!       Line segments:
!       --------------
        CASE( 2 )
        SELECT CASE( n )
           CASE( 2 )
           IntegStuff = GaussPoints( element,1 )
           CASE( 3 )
           IntegStuff = GaussPoints( element,4 )
           CASE( 4 )
           IntegStuff = GaussPoints( element,5 )
           CASE DEFAULT
           CALL Fatal( 'ElasticSolve',  'Unknown number of nodes.' )
        END SELECT

!       Triangles:
!       ----------
        CASE( 3 )
        SELECT CASE( n )
           CASE( 3 )
           IntegStuff = GaussPoints( element,1 )
           CASE( 6 )
           IntegStuff = GaussPoints( element,7 )
           CASE( 10 )
           IntegStuff = GaussPoints( element,17 )
           CASE DEFAULT
           CALL Fatal( 'ElasticSolve',  'Unknown number of nodes.' )
        END SELECT

!       Quadrilaterals:
!       ---------------
        CASE( 4 )
        SELECT CASE( n )
           CASE( 4 )
           IntegStuff = GaussPoints( element,4 )
           CASE( 8,9 )
           IntegStuff = GaussPoints( element,16 )
           CASE( 12,16 )
           IntegStuff = GaussPoints( element,25 )
           CASE DEFAULT
           CALL Fatal( 'ElasticSolve',  'Unknown number of nodes.' )
        END SELECT

!       Tetrahedrons:
!       -------------
        CASE( 5 )
        SELECT CASE( n )
           CASE( 4 )
           IntegStuff = GaussPoints( element,1 )
           CASE( 10 )
           IntegStuff = GaussPoints( element,11 )
           CASE DEFAULT
           CALL Fatal( 'ElasticSolve',  'Unknown number of nodes.' )
        END SELECT

!       Octahedrons:
!       ------------
        CASE( 8 )
        SELECT CASE( n )
           CASE( 8 )
           IntegStuff = GaussPoints( element,8 )
           CASE( 20,27 )
           IntegStuff = GaussPoints( element,64 )
           CASE DEFAULT
           CALL Fatal( 'ElasticSolve',  'Unknown number of nodes.' )
        END SELECT

!       Others:
!       -------
        CASE DEFAULT
           CALL Fatal( 'ElasticSolve',  'Unknown element type.' )

     END SELECT

     U_Integ => IntegStuff % u
     V_Integ => IntegStuff % v
     W_Integ => IntegStuff % w
     S_Integ => IntegStuff % s
     N_Integ =  IntegStuff % n
!
!   Now we start integrating
!
    DO t=1,N_Integ

      u = U_Integ(t)
      v = V_Integ(t)
      w = W_Integ(t)

!------------------------------------------------------------------------------
!     Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
                 Basis,dBasisdx )

!------------------------------------------------------------------------------
!     Coordinate system dependent info
!------------------------------------------------------------------------------
      IF ( CoordinateSystem /= Cartesian ) THEN
         X = SUM( nodes % x(1:n)*Basis )
         Y = SUM( nodes % y(1:n)*Basis )
         Z = SUM( nodes % z(1:n)*Basis )
      END IF

      CALL CoordinateSystemInfo( Metric, SqrtMetric, Symb, dSymb, X, Y, Z )

      s = SqrtMetric * SqrtElementMetric * S_Integ(t)

!------------------------------------------------------------------------------
!  
!     Force at integration point
!   
      Force = 0.0D0
      DO i=1,dim
        Force(i) = SUM( LoadVector(i,1:n)*Basis )
      END DO

!     Lame parameters at the integration point
!
      Lame1 = SUM( NodalLame1(1:n)*Basis )
      Lame2 = SUM( NodalLame2(1:n)*Basis )
      Density = SUM( NodalDensity(1:n)*Basis )
      Damping = SUM( NodalDamping(1:n)*Basis )
!
!     Temperature at the integration point
!
      Temperature = SUM( NodalTemperature(1:n)*Basis )
!
!     Heat expansion tensor values at the integration point
!
!      DO i=1,3
!        DO j=1,3
!          HeatExpansion(i,j) = SUM( NodalHeatExpansion(i,j,1:n)*Basis )
!        END DO
!      END DO

!===========================================================================
!
!                       S T I F F N E S S   M A T R I X 
!
!                                    A N D
!
!                   R E S I D U A L   F O R C E   V E C T O R
!
!===========================================================================

!      Covariant gradient of the current solution:
!      -------------------------------------------
       Metric(1,1) = 1.0D0/Metric(1,1)
       Metric(2,2) = 1.0D0/Metric(2,2)
       Metric(3,3) = 1.0D0/Metric(3,3)

       Grad = MATMUL(NodalDisplacement(:,1:N),dBasisdx)
       IF ( CoordinateSystem /= Cartesian ) THEN
!         Contravariant components of the displacement:
          Disp = MATMUL(NodalDisplacement(:,1:N),Basis)
!         Account for the Christoffel symbols:
          DO i = 1,dim
             DO j = 1,dim
                DO k = 1,dim
                   Grad(i,j) = Grad(i,j) + Symb(j,k,i) * Disp(k)
                END DO
             END DO
          END DO
       END IF

!      Deformation gradient
!      --------------------
       DefG = Identity + Grad
       dDefG = Grad
       DetDefG = 1.0D0

!      Covariant components of the strain tensor:
!      ------------------------------------------
       Strain = 0.0D0
       DO i = 1,dim
          DO j = i,dim
             DO k = 1,dim
                Strain(i,j) = Strain(i,j) + Metric(i,k)*Grad(k,j)
                DO l = 1,dim
                   Strain(i,j) = Strain(i,j) + Metric(k,l)*Grad(k,i)*Grad(l,j)/2.0D0
                END DO
             END DO
          END DO
       END DO
       Strain = (Strain + TRANSPOSE(Strain))/2.0D0

       Stress2 = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,dim)*Identity
       Stress1 = MATMUL( DefG, Stress2 )

       DetDefG = 1.0d0

!       SELECT CASE( dim )
!          CASE( 1 )
!          DetDefG = DefG(1,1)
!          CASE( 2 )
!          DetDefG = DefG(1,1)*DefG(2,2) - DefG(1,2)*DefG(2,1)
!          CASE( 3 )
!          DetDefG = DefG(1,1) * ( DefG(2,2)*DefG(3,3) - DefG(2,3)*DefG(3,2) ) + &
!                    DefG(1,2) * ( DefG(2,3)*DefG(3,1) - DefG(2,1)*DefG(3,3) ) + &
!                    DefG(1,3) * ( DefG(2,1)*DefG(3,2) - DefG(2,2)*DefG(3,1) )
!       END SELECT

!      Gateaux derivatives of the deformation gradient, stress
!      and strain, with respect to the current displacement:
!      -------------------------------------------------------
       dStrainU = 0.0D0
       DO i = 1,dim
          DO j = 1,dim
             DO k = 1,dim
                DO l = 1,dim
                   dStrainU(i,j) = dStrain(i,j) + Metric(k,l)*Grad(k,i)*Grad(l,j)/2.0D0
                END DO
             END DO
          END DO
       END DO

       dStress2U = 2.0D0*Lame2*dStrainU + Lame1*TRACE(dStrainU,dim)*Identity
       dStress1U = MATMUL(dDefGU,Stress2) + MATMUL(DefG,dStress2U)

       IF ( CoordinateSystem == AxisSymmetric ) THEN
          Bound = 2
       ELSE
          Bound = dim
       END IF

!      Loop over the test funtions:
!      ----------------------------
       DO p = 1,N
          DO i = 1,Bound

!            Gateaux derivatives of the solution with respect to the test functions:
!            -----------------------------------------------------------------------
             GradTest = 0.0D0
             GradTest(i,:) = dBasisdx(p,:)
             IF ( CoordinateSystem /= Cartesian ) THEN
                Disp = 0.0D0; Disp(i) = Basis(p)
                DO i2 = 1,dim
                   DO j2 = 1,dim
                      DO k2 = 1,dim
                         GradTest(i2,j2) = GradTest(i2,j2) - Symb(i2,j2,k2) * Disp(k2)
                      END DO
                   END DO
                END DO
             END IF

             dStrain = 0.0D0
             DO i2 = 1,dim
                DO j2 = i,dim
                   DO k2 = 1,dim
                      dStrain(i2,j2) = dStrain(i2,j2) &
                           + ( Metric(i2,k2)*GradTest(k2,j2) &
                           +   Metric(j2,k2)*GradTest(k2,i2) )/2.0D0
                      DO l2 = 1,dim
                         dStrain(i2,j2) = dStrain(i2,j2) &
                              + Metric(k2,l2)*GradTest(k2,i2)*GradTest(l2,j2)/2.0D0
                      END DO
                   END DO
                END DO
             END DO

             dDefG = GradTest
!             dStrain = (MATMUL(TRANSPOSE(DefG),dDefG) &
!                  + MATMUL(TRANSPOSE(dDefG),DefG))/2.0D0

             dStress2 = 2.0D0*Lame2*dStrain + Lame1*TRACE(dStrain,dim)*Identity
             dStress1 = MATMUL(dDefG,Stress2) + MATMUL(DefG,dStress2)

             ForceVector(Bound*(p-1)+i) = ForceVector(Bound*(p-1)+i) &
                  +(Basis(p)*Force(i)*DetDefG &
                   -DDOT_PRODUCT( Stress1 , dDefG, 3) &
                   +DDOT_PRODUCT(dStress1U, dDefG, 3) )*s

!            Loop over the basis functions:
!            ------------------------------
             DO q = 1,N
                DO j = 1,Bound

!                  Contravariant components of the test function:
!                  ----------------------------------------------
                   GradBasis = 0.0D0; GradBasis(j,:) = dBasisdx(q,:)
                   
!                  Covariant derivatives:
!                  ----------------------
                   IF ( CoordinateSystem /= Cartesian ) THEN
                      Disp = 0.0D0; Disp(j) = Basis(q)
                      DO i2 = 1,dim
                         DO j2 = 1,dim
                            DO k2 = 1,dim
                               GradBasis(i2,j2) = GradBasis(i2,j2) + Symb(j2,k2,i2) * Disp(k2)
                            END DO
                         END DO
                      END DO
                   END IF

                   MassMatrix(Bound*(p-1)+i,Bound*(q-1)+j) &
                        = MassMatrix(Bound*(p-1)+i,Bound*(q-1)+j) &
                        + Basis(p)*Basis(q)*Density*DetDefG*s

                   StiffMatrix(Bound*(p-1)+i,Bound*(q-1)+j) &
                        = StiffMatrix(Bound*(p-1)+i,Bound*(q-1)+j) &
                        + DDOT_PRODUCT(dStress1,GradBasis,3)*s

                END DO
             END DO
          END DO
       END DO

!      Rayleigh damping:
!      -----------------
       DampMatrix = Damping * MassMatrix

    END DO

!------------------------------------------------------------------------------

  END SUBROUTINE BackStressGeneralCompose
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
 SUBROUTINE LocalBoundaryMatrix( BoundaryMatrix,BoundaryVector,LoadVector, &
   NodalAlpha,NodalBeta,NodalDisplacement,Element,n,Nodes, &
     Parent,pn,ParentNodes,Flow,fn,FlowNodes,Velocity,Pressure,NodalViscosity, &
     NodalDensity, CompressibilityDefined )
   USE Integration
   USE LinearAlgebra
!------------------------------------------------------------------------------
   REAL(KIND=dp) :: BoundaryMatrix(:,:),BoundaryVector(:),NodalDisplacement(:,:)
   REAL(KIND=dp) :: NodalAlpha(:,:),NodalBeta(:),LoadVector(:,:),Pressure(:), &
                    Velocity(:,:),NodalViscosity(:), NodalDensity(:)
   TYPE(Element_t),POINTER  :: Element,Parent,Flow
   TYPE(Nodes_t)    :: Nodes,ParentNodes,FlowNodes
   INTEGER :: n,pn,fn
   LOGICAL :: CompressibilityDefined
!------------------------------------------------------------------------------
   REAL(KIND=dp) :: Basis(n)
   REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric
   REAL(KIND=dp) :: x(n),y(n),z(n), fx(n), fy(n), fz(n), Density

   REAL(KIND=dp) :: PBasis(pn)
   REAL(KIND=dp) :: PdBasisdx(pn,3),PSqrtElementMetric

   REAL(KIND=dp) :: FBasis(fn)
   REAL(KIND=dp) :: FdBasisdx(fn,3),FSqrtElementMetric

   REAL(KIND=dp) :: u,v,w,s,ParentU,ParentV,ParentW
   REAL(KIND=dp) :: FlowStress(3,3),Viscosity
   REAL(KIND=dp) :: Force(3),Alpha(3),Beta,Normal(3), Identity(3,3)
   REAL(KIND=dp) :: Grad(3,3),DefG(3,3),DetDefG,CofG(3,3),ScaleFactor
   REAL(KIND=dp), POINTER :: U_Integ(:),V_Integ(:),W_Integ(:),S_Integ(:)

   INTEGER :: i,j,t,q,p,dim,N_Integ

   LOGICAL :: stat,pstat

   TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
!------------------------------------------------------------------------------

   dim = CoordinateSystemDimension()

   Identity = 0.0D0
   DO i = 1,dim
      Identity(i,i) = 1.0D0
   END DO

   BoundaryVector = 0.0D0
   BoundaryMatrix = 0.0D0
   
   DO i = 1,n
     DO j = 1,pn
       IF( Element % NodeIndexes(i) == Parent % NodeIndexes(j) ) THEN
          x(i) = Parent % TYPE % NodeU(j)
          y(i) = Parent % TYPE % NodeV(j)
          z(i) = Parent % TYPE % NodeW(j)
          EXIT
       END IF
     END DO
   END DO

   IF ( ASSOCIATED( Flow ) ) THEN
     DO i = 1,n
       DO j = 1,fn
         IF ( Element % NodeIndexes(i) == Flow % NodeIndexes(j) ) THEN
           fx(i) = Flow % TYPE % NodeU(j)
           fy(i) = Flow % TYPE % NodeV(j)
           fz(i) = Flow % TYPE % NodeW(j)
           EXIT
         END IF
       END DO
     END DO
   END IF

!
!  Integration stuff
!
   IntegStuff = GaussPoints( element, element % TYPE % GaussPoints )
   U_Integ => IntegStuff % u
   V_Integ => IntegStuff % v
   W_Integ => IntegStuff % w
   S_Integ => IntegStuff % s
   N_Integ =  IntegStuff % n
!
!  Now we start integrating
!
   DO t=1,N_Integ

      u = U_Integ(t)
      v = V_Integ(t)
      w = W_Integ(t)

!------------------------------------------------------------------------------
!     Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
                 Basis,dBasisdx )

      s = SqrtElementMetric * S_Integ(t)

!     Calculate the basis functions for the parent element:
!     -----------------------------------------------------
      ParentU = SUM( Basis(1:n)*x(1:n) )
      ParentV = SUM( Basis(1:n)*y(1:n) )
      ParentW = SUM( Basis(1:n)*z(1:n) )

      Pstat= ElementInfo( Parent,ParentNodes,ParentU,ParentV,ParentW, &
           PSqrtElementMetric,PBasis,PdBasisdx )

!     Computes the cofactor matrix of the deformation gradient:
!     ---------------------------------------------------------
      Grad = MATMUL(NodalDisplacement(:,1:pn),PdBasisdx)
      DefG = Identity + Grad 
      SELECT CASE( dim )
         CASE(1)
            DetDefG = DefG(1,1)
         CASE(2)
            DetDefG = DefG(1,1)*DefG(2,2) - DefG(1,2)*DefG(2,1)
         CASE(3)
            DetDefG = DefG(1,1) * ( DefG(2,2)*DefG(3,3) - DefG(2,3)*DefG(3,2) ) + &
                      DefG(1,2) * ( DefG(2,3)*DefG(3,1) - DefG(2,1)*DefG(3,3) ) + &
                      DefG(1,3) * ( DefG(2,1)*DefG(3,2) - DefG(2,2)*DefG(3,1) )
      END SELECT
      CALL InvertMatrix( DefG, dim )     ! Inverse of the deformation gradient
      DefG = DetDefG*TRANSPOSE( DefG )   ! Cofactor of the deformation gradient

!     Calculate traction from the flow solution:
!     ------------------------------------------
      IF ( ASSOCIATED( Flow ) ) THEN
        ParentU = SUM( Basis(1:n)*fx(1:n) )
        ParentV = SUM( Basis(1:n)*fy(1:n) )
        ParentW = SUM( Basis(1:n)*fz(1:n) )

        Pstat = ElementInfo( Flow,FlowNodes,ParentU,ParentV,ParentW, &
              FSqrtElementMetric,FBasis,FdBasisdx )

        Grad = MATMUL( Velocity(:,1:fn),FdBasisdx )
        Density    = SUM( NodalDensity(1:fn) * FBasis )
        Viscosity  = SUM( NodalViscosity(1:fn) * FBasis )

        Viscosity = EffectiveViscosity( Viscosity,Density,Velocity(1,:),Velocity(2,:), &
             Velocity(3,:),FlowElement,FlowNodes,fn,fn,ParentU,ParentV,ParentW)
        Viscosity  = SUM( NodalViscosity(1:fn) * FBasis )
 
        FlowStress = Viscosity * ( Grad + TRANSPOSE(Grad) )

        DO i=1,dim
          FlowStress(i,i) = FlowStress(i,i) - SUM( Pressure(1:fn)*FBasis )
          IF( CompressibilityDefined ) THEN
             FlowStress(i,i) = FlowStress(i,i) - Viscosity * (2.0d0/3.0d0)*TRACE(Grad,dim)
          END IF
        END DO

      END IF

!------------------------------------------------------------------------------
!     The following four lines scale the vectors of the cofactor matrix to unit
!     vectors. These lines are only for testing and should be commented out in
!     the final code.
!     -------------------------------------------------------------------------
!       ScaleFactor = SQRT( DefG(1,1)**2 + DefG(2,1)**2 )
!       DefG(:,1) = DefG(:,1)/ScaleFactor
!       ScaleFactor = SQRT( DefG(1,2)**2 + DefG(2,2)**2 )
!       DefG(:,2) = DefG(:,2)/ScaleFactor
!------------------------------------------------------------------------------

      Force = 0.0D0
      DO i=1,dim
        Force(i) = SUM( LoadVector(i,1:n)*Basis )
        Alpha(i) = SUM( NodalAlpha(i,1:n)*Basis )
      END DO

!     Normal vector and its transformation:
!     --------------------------------------
      Normal = NormalVector( Element,Nodes,u,v,.TRUE. )
      Normal = MATMUL(DefG,Normal)

      IF ( ASSOCIATED( Flow ) ) THEN
        Force = Force + MATMUL( FlowStress, Normal )
      END IF
      Force = Force + SUM( NodalBeta(1:n)*Basis ) * Normal

      DO p=1,N
         DO q=1,N
            DO i=1,dim
               BoundaryMatrix((p-1)*dim+i,(q-1)*dim+i) =  &
                    BoundaryMatrix((p-1)*dim+i,(q-1)*dim+i) + &
                    s * Alpha(i) * Basis(q) * Basis(p)
            END DO
         END DO
      END DO
     
      DO q=1,N
         DO i=1,dim
            BoundaryVector((q-1)*dim+i) = BoundaryVector((q-1)*dim+i) + &
                 s * Basis(q) * Force(i)
         END DO
      END DO
     
  END DO

!------------------------------------------------------------------------------
 END SUBROUTINE LocalBoundaryMatrix
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
 SUBROUTINE StressGeneralBoundary( BoundaryMatrix,BoundaryVector,LoadVector, &
   NodalAlpha,NodalBeta,NodalDisplacement,Element,n,Nodes, &
     Parent,pn,ParentNodes,Flow,fn,FlowNodes,Velocity,Pressure,NodalViscosity, &
     NodalDensity, CompressibilityDefined )
!------------------------------------------------------------------------------
   REAL(KIND=dp) :: BoundaryMatrix(:,:),BoundaryVector(:),NodalDisplacement(:,:)
   REAL(KIND=dp) :: NodalAlpha(:,:),NodalBeta(:),LoadVector(:,:),Pressure(:), &
                    Velocity(:,:),NodalViscosity(:), NodalDensity(:)
   TYPE(Element_t),POINTER  :: Element,Parent,Flow
   TYPE(Nodes_t)    :: Nodes,ParentNodes,FlowNodes
   INTEGER :: n,pn,fn
   LOGICAL :: CompressibilityDefined
!------------------------------------------------------------------------------
   REAL(KIND=dp) :: Basis(n)
   REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric
   REAL(KIND=dp) :: x(n),y(n),z(n), Density

   REAL(KIND=dp) :: PBasis(pn)
   REAL(KIND=dp) :: PdBasisdx(pn,3),PSqrtElementMetric

   REAL(KIND=dp) :: FBasis(fn)
   REAL(KIND=dp) :: FdBasisdx(fn,3),FSqrtElementMetric

   REAL(KIND=dp) :: u,v,w,s,ParentU,ParentV,ParentW
   REAL(KIND=dp) :: FlowStress(3,3),Viscosity
   REAL(KIND=dp) :: Force(3),Alpha(3),Beta,Normal(3),Identity(3,3)
   REAL(KIND=dp) :: Grad(3,3),DefG(3,3),DetDefG,CofG(3,3),ScaleFactor
   REAL(KIND=dp), POINTER :: U_Integ(:),V_Integ(:),W_Integ(:),S_Integ(:)

   INTEGER :: i,j,t,q,p,dim,N_Integ

   LOGICAL :: stat,pstat

   TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

   REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3),xx,yy,zz
!------------------------------------------------------------------------------

   dim = Element % TYPE % DIMENSION + 1

   BoundaryVector = 0.0D0
   BoundaryMatrix = 0.0D0
!
!  Integration stuff
!
   IntegStuff = GaussPoints( element )
   U_Integ => IntegStuff % u
   V_Integ => IntegStuff % v
   W_Integ => IntegStuff % w
   S_Integ => IntegStuff % s
   N_Integ =  IntegStuff % n
!
!  Now we start integrating
!
   DO t=1,N_Integ

     u = U_Integ(t)
     v = V_Integ(t)
     w = W_Integ(t)

!------------------------------------------------------------------------------
!     Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
                 Basis,dBasisdx )

!------------------------------------------------------------------------------
!
!    CoordinateSystemystem dependent info
!
     IF ( CoordinateSystem /= Cartesian ) THEN
       XX = SUM( nodes % x(1:n)*Basis )
       YY = SUM( nodes % y(1:n)*Basis )
       ZZ = SUM( nodes % z(1:n)*Basis )
     END IF

     CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,XX,YY,ZZ )
!
     s = 2.0d0 * Pi * SqrtMetric * SqrtElementMetric * S_Integ(t)

!     Calculate the basis functions for the parent element:
!     -----------------------------------------------------
      DO i = 1,n
         DO j = 1,pn
            IF( Element % NodeIndexes(i) == Parent % NodeIndexes(j) ) THEN
               x(i) = Parent % TYPE % NodeU(j)
               y(i) = Parent % TYPE % NodeV(j)
               z(i) = Parent % TYPE % NodeW(j)
               EXIT
            END IF
         END DO
      END DO

      ParentU = SUM( Basis(1:n)*x(1:n) )
      ParentV = SUM( Basis(1:n)*y(1:n) )
      ParentW = SUM( Basis(1:n)*z(1:n) )

      Pstat= ElementInfo( Parent,ParentNodes,ParentU,ParentV,ParentW, &
           PSqrtElementMetric,PBasis,PdBasisdx )

!     Calculate traction from the flow solution:
!     ------------------------------------------
      IF ( ASSOCIATED( Flow ) ) THEN
        DO i = 1,n
          DO j = 1,fn
            IF ( Element % NodeIndexes(i) == Flow % NodeIndexes(j) ) THEN
              x(i) = Flow % TYPE % NodeU(j)
              y(i) = Flow % TYPE % NodeV(j)
              z(i) = Flow % TYPE % NodeW(j)
              EXIT
            END IF
          END DO
        END DO

        ParentU = SUM( Basis(1:n)*x(1:n) )
        ParentV = SUM( Basis(1:n)*y(1:n) )
        ParentW = SUM( Basis(1:n)*z(1:n) )

        Pstat = ElementInfo( Flow,FlowNodes,ParentU,ParentV,ParentW, &
          FSqrtElementMetric,FBasis,FdBasisdx )

        Grad = MATMUL( Velocity(:,1:fn),FdBasisdx )
        Density    = SUM( NodalDensity(1:fn) * FBasis )
        Viscosity  = SUM( NodalViscosity(1:fn) * FBasis )

        Viscosity = EffectiveViscosity( Viscosity,Density,Velocity(1,:),Velocity(2,:), &
             Velocity(3,:),FlowElement,FlowNodes,fn,fn,ParentU,ParentV,ParentW)
 
        FlowStress = Viscosity * ( Grad + TRANSPOSE(Grad) )

        DO i=1,dim
          FlowStress(i,i) = FlowStress(i,i) - SUM( Pressure(1:fn)*FBasis )
          IF( CompressibilityDefined ) THEN
             FlowStress(i,i) = FlowStress(i,i) - Viscosity * (2.0d0/3.0d0)*TRACE(Grad,dim)
          END IF
        END DO
      END IF

      Force = 0.0D0
      Alpha = 0.0D0
      DO i=1,dim
        Force(i) = SUM( LoadVector(i,1:n)*Basis )
        Alpha(i) = SUM( NodalAlpha(i,1:n)*Basis )
      END DO

!     Normal vector and its transformation:
!     --------------------------------------
      Normal = NormalVector( Element,Nodes,u,v,.TRUE. )
!     Normal = MATMUL(DefG,Normal)

      IF ( ASSOCIATED( Flow ) ) THEN
         Force = Force + MATMUL( FlowStress, Normal )
      END IF

!------------------------------------------------------------------------------
!    Add to load: given force in normal direction
!------------------------------------------------------------------------------
!
     Beta  = SUM( NodalBeta(1:n)*Basis )
     DO i=1,dim
       DO j=1,dim
         Force(i) = Force(i) + Beta*Metric(i,j)*Normal(j)
       END DO
     END DO
!------------------------------------------------------------------------------
!
     DO p=1,N
       DO q=1,N
         DO i=1,dim
           BoundaryMatrix((p-1)*dim+i,(q-1)*dim+i) =  &
               BoundaryMatrix((p-1)*dim+i,(q-1)*dim+i) + &
                  s * Alpha(i) * Basis(q) * Basis(p)
         END DO
       END DO
     END DO

     DO q=1,N
       DO i=1,dim
         BoundaryVector((q-1)*dim+i) = BoundaryVector((q-1)*dim+i) + &
                      s * Basis(q) * Force(i)
       END DO
     END DO

   END DO
!------------------------------------------------------------------------------
 END SUBROUTINE StressGeneralBoundary
!------------------------------------------------------------------------------



!--------------------------------------------------------------------------------
 SUBROUTINE ComputeStressAndStrain( Displacement, NodalStrain, NodalStress, VonMises, Perm , &
      CalculateStrains, CalcStressAll, NeoHookeanMaterial, PrincipalStress, PrincipalStrain, &
      Tresca, PrincipalAngle)
!--------------------------------------------------------------------------------
   REAL(KIND=dp) :: Displacement(:), NodalStrain(:), NodalStress(:), VonMises(:), &
    PrincipalStress(:), PrincipalStrain(:), Tresca(:), PrincipalAngle(:) 
   INTEGER, POINTER :: Perm(:)
   LOGICAL :: CalculateStrains, CalcStressAll, NeoHookeanMaterial
!--------------------------------------------------------------------------------
   TYPE(Solver_t), POINTER :: StSolver
   TYPE(Nodes_t) :: Nodes
   TYPE(Element_t), POINTER :: Element
   TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
   TYPE(ValueList_t), POINTER :: Equation
   
   INTEGER, POINTER :: Permutation(:), Indeces(:)
   REAL(KIND=dp), POINTER :: StressTemp(:)
   REAL(KIND=dp), ALLOCATABLE :: ForceG(:), SForceG(:), LocalDisplacement(:,:), &
        Mass(:,:), Force(:), SForce(:), Basis(:), dBasisdx(:,:), &
        NodalLame1(:), NodalLame2(:)

   LOGICAL :: FirstTime = .TRUE., Found, OptimizeBW, GlobalBubbles, Stat, &
        Factorize,  FoundFactorize, FreeFactorize, FoundFreeFactorize, PlaneStress, &
        Isotropic, UseMask
   INTEGER :: dim, n, nd, elem, i, j, k, l, p, q, t, Ind(9)
   REAL(KIND=dp) :: Strain(3,3), Stress(3,3), Stress2(3,3), Grad(3,3), DefG(3,3), Identity(3,3), &
        InvC(3,3), InvDefG(3,3), u, v, w, Weight, detJ, res, Lame1, Lame2, DetDefG, G(6,6)
   CHARACTER(LEN=MAX_NAME_LEN) :: eqname

   SAVE StSolver, Permutation, FirstTime, ForceG, SForceG, Nodes, StressTemp, Eqname
!--------------------------------------------------------------------------------

   ! These variables are needed for Principal stress calculation
   ! they are quite small and allocated even if principal stress calculation
   ! is not requested
   REAL(KIND=dp) :: PriCache(3,3), PriTmp, PriW(3),PriWork(102)
   INTEGER       :: PriN=3, PriLWork=102, PriInfo=0
   REAL(KIND=dp) :: PriAngT1=0, PriAngT2=0, PriAngV(3)=0

   dim = CoordinateSystemDimension()   
 
   Identity = 0.0D0
   DO i = 1,dim
      Identity(i,i) = 1.0D0
   END DO

   n = Solver % Mesh % MaxElementDOFs
   ALLOCATE( Indeces(n), &
        LocalDisplacement(3,n), &
        Mass(n,n), &
        Force(6*n), &
        SForce(6*n), &
        Basis(n), &
        dBasisdx(n,3), &
        NodalLame1(n), &
        NodalLame2(n) )   

   IF (FirstTime) THEN
      ALLOCATE( StSolver )
      StSolver = Solver

      ALLOCATE( Permutation( SIZE(Solver % Variable % Perm) ) )
      ! Permutation = Perm

      CALL ListSetNameSpace('stress:')

      OptimizeBW = GetLogical( StSolver % Values, 'Optimize Bandwidth', Found )
      IF ( .NOT. Found ) OptimizeBW = .TRUE.
      GlobalBubbles = GetLogical( StSolver % Values, 'Bubbles in Global System', Found )
      IF ( .NOT. Found ) GlobalBubbles = .TRUE.

      IF( ListGetLogicalAnyEquation( Model,'Calculate Stresses' ) ) THEN
        UseMask = .TRUE.
        eqname = 'Calculate Stresses'
      ELSE
        UseMask = .FALSE.
        eqname = TRIM( ListGetString( StSolver % Values,'Equation') )
      END IF
      StSolver % Matrix => CreateMatrix( Model, Solver, Solver % Mesh, Permutation, &
            1, MATRIX_CRS, OptimizeBW,eqname, GlobalBubbles=GlobalBubbles )

      ALLOCATE( StSolver % Matrix % RHS(StSolver % Matrix % NumberOfRows) )
      StSolver % Matrix % Comm = Solver % Matrix % Comm      

      IF (CalculateStrains) ALLOCATE( ForceG(StSolver % Matrix % NumberOfRows*6) )
      IF (CalcStressAll) ALLOCATE( SForceG(StSolver % Matrix % NumberOfRows*6) )

      ALLOCATE( StressTemp(StSolver % Matrix % NumberOfRows) )
      StressTemp   = 0.0d0

      CALL VariableAdd( StSolver % Mesh % Variables, StSolver % Mesh, StSolver, &
           'StressTemp', 1, StressTemp, Perm, Output=.FALSE. )
      StSolver % Variable => VariableGet( StSolver % Mesh % Variables, 'StressTemp' )

      FirstTime = .FALSE.
    ELSE
      CALL ListSetNameSpace('stress:')
    END IF

   Model % Solver => StSolver
   Ind = (/ 1, 4, 6, 4, 2, 5, 6, 5, 3 /)

   IF (CalculateStrains) THEN
      NodalStrain = 0.0d0
      ForceG      = 0.0d0
   END IF
   IF (CalcStressAll) THEN
      NodalStress = 0.0d0
      SForceG      = 0.0d0
   END IF
   CALL DefaultInitialize()

   !------------------------------------------------------------------------
   ! Assembly loop 
   !------------------------------------------------------------------------
   DO elem = 1, Solver % NumberOfActiveElements
      Element => GetActiveElement(elem, Solver)
      n  = GetElementNOFNodes()
      nd = GetElementDOFs( Indeces )

      CALL GetElementNodes( Nodes )
      CALL GetVectorLocalSolution( LocalDisplacement, USolver=Solver )
      
      !-------------------------------------------------------------------
      ! Find material parameters
      !--------------------------------------------------------------------
      Equation => GetEquation()
      Material => GetMaterial()

      ! Check if stresses wanted for this body:
      ! ---------------------------------------
      IF( UseMask ) THEN
        IF(.NOT. GetLogical( Equation, eqname, Found )) THEN
          PRINT *,'not active:',TRIM(eqname)
          CYCLE
        END IF
      END IF

      IF (NeoHookeanMaterial) THEN
         Isotropic = .TRUE.
         ElasticModulus(1,1,1:n) = ListGetReal( Material, &
              'Youngs Modulus', n, Indeces, Found )
      ELSE
         CALL InputTensor( ElasticModulus, Isotropic, &
              'Youngs Modulus', Material, n, Indeces )        
      END IF

      !------------------------------------------------------------------------------
      ! Check whether the rotation transformation of elastic moduli is necessary...
      !------------------------------------------------------------------------------
      RotateModuli = GetLogical( Material, 'Rotate Elasticity Tensor', Found )
      IF ( RotateModuli .AND. (.NOT. Isotropic) ) THEN
         RotateModuli = .FALSE.
         DO i=1,3
            IF( i == 1 ) THEN
               CALL GetConstRealArray( Material, UWrk, &
                    'Material Coordinates Unit Vector 1', Found, Element )
            ELSE IF( i == 2 ) THEN
               CALL GetConstRealArray( Material, UWrk, &
                    'Material Coordinates Unit Vector 2', Found, Element )
            ELSE                
               CALL GetConstRealArray( Material, UWrk, &
                    'Material Coordinates Unit Vector 3', Found, Element )
            END IF

            IF( Found ) THEN
               UnitNorm = SQRT( SUM( Uwrk(1:3,1)**2 ) )
               IF( UnitNorm < EPSILON( UnitNorm ) ) THEN
                  CALL Fatal('ElasticSolve','Given > Materia Coordinate Unit Vector < too short!')
               END IF
               TransformMatrix(i,1:3) = Uwrk(1:3,1) / UnitNorm  
               RotateModuli = .TRUE.
            ELSE 
               TransformMatrix(i,1:3) = 0.0_dp
               TransformMatrix(i,i) = 1.0_dp
            END IF
         END DO

         IF( .NOT. RotateModuli  ) THEN
            CALL Fatal( 'ElasticSolve', &
                 'No unit vectors found but > Rotate Elasticity Tensor < set True?' )
         END IF
      END IF

      PoissonRatio = 0.0d0
      IF (Isotropic) THEN
         PoissonRatio(1:n) = ListGetReal( Material, &
              'Poisson Ratio', n, Indeces )

         PlaneStress = GetLogical( Equation, 'Plane Stress', Found )

         IF ( PlaneStress ) THEN
            NodalLame1(1:n) = ElasticModulus(1,1,1:n) * PoissonRatio(1:n) /  &
                 ( (1.0d0 - PoissonRatio(1:n)**2) )
         ELSE
            NodalLame1(1:n) = ElasticModulus(1,1,1:n) * PoissonRatio(1:n) /  &
                 (  (1.0d0 + PoissonRatio(1:n)) * (1.0d0 - 2.0d0*PoissonRatio(1:n)) )
         END IF
         NodalLame2(1:n) = ElasticModulus(1,1,1:n)  / ( 2* (1.0d0 + PoissonRatio(1:n)) )
      END IF


      IntegStuff = GaussPoints( Element )      
      Strain = 0.0d0
      Stress = 0.0d0
      Mass = 0.0d0
      Force = 0.0d0      
      SForce = 0.0d0        

      DO t=1,IntegStuff % n
         u = IntegStuff % u(t)
         v = IntegStuff % v(t)
         w = IntegStuff % w(t)
         Weight = IntegStuff % s(t)

         stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
              Basis, dBasisdx ) 
         Weight = Weight * detJ
 
         IF (Isotropic) THEN
            Lame1 = SUM( NodalLame1(1:n)*Basis(1:n) )
            Lame2 = SUM( NodalLame2(1:n)*Basis(1:n) )
         ELSE
            G = 0.0d0
            DO i=1,SIZE(ElasticModulus,1)
               DO j=1,SIZE(ElasticModulus,2)
                  G(i,j) = SUM( Basis(1:n) * ElasticModulus(i,j,1:n) )
               END DO
            END DO

            IF ( RotateModuli ) THEN
               CALL RotateElasticityMatrix( G, TransformMatrix, dim )
            END IF
         END IF

         Grad = 0.0d0
         Grad = MATMUL( LocalDisplacement(1:dim,1:nd), dBasisdx(1:nd,1:dim) )
         DefG = Identity + Grad

         SELECT CASE( dim )
         CASE( 1 )
            DetDefG = DefG(1,1)
         CASE( 2 )
            DetDefG = DefG(1,1)*DefG(2,2) - DefG(1,2)*DefG(2,1)
         CASE( 3 )
            DetDefG = DefG(1,1) * ( DefG(2,2)*DefG(3,3) - DefG(2,3)*DefG(3,2) ) + &
                 DefG(1,2) * ( DefG(2,3)*DefG(3,1) - DefG(2,1)*DefG(3,3) ) + &
                 DefG(1,3) * ( DefG(2,1)*DefG(3,2) - DefG(2,2)*DefG(3,1) )
         END SELECT

         Strain = (TRANSPOSE(Grad)+Grad+MATMUL(TRANSPOSE(Grad),Grad))/2.0D0

         IF (NeoHookeanMaterial) THEN
            InvC = MATMUL( TRANSPOSE(DefG), DefG )
            InvDefG = DefG
            !-------------------------------------------------------------
            !  InvC will now be the inverse of the right Cauchy-Green tensor
            !-------------------------------------------------------------
            CALL InvertMatrix( InvC, dim )
            CALL InvertMatrix( InvDefG, dim )       
            !-------------------------------------------------------------
            ! The second Piola-Kirchhoff stress for the current iterate
            !--------------------------------------------------------------
            Stress2 = Lame1/2.0d0 * (DetDefG - 1.0d0) * (DetDefG + 1.0d0) * InvC + &
                 Lame2 * (Identity - InvC)
         ELSE
            IF (.NOT. Isotropic) THEN
               CALL Strain2Stress(Stress2, Strain, G, dim, .FALSE.) 
            ELSE
               Stress2 = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,dim)*Identity
            END IF
         END IF
         Stress =  1.0d0/DetDefG * MATMUL( MATMUL(DefG,Stress2), TRANSPOSE(DefG) )

         DO p=1,nd
            DO q=1,nd
               Mass(p,q) = Mass(p,q) + Weight * Basis(q) * Basis(p)
            END DO  
      
            IF (CalculateStrains) THEN
               DO i=1,3
                  DO j=i,3
                     k = Ind( 3*(i-1)+j )
                     Force(6*(p-1)+k) = Force(6*(p-1)+k) + Weight * Strain(i,j) * Basis(p)
                  END DO
               END DO
            END IF
            IF (CalcStressAll) THEN
               DO i=1,3
                  DO j=i,3
                     k = Ind( 3*(i-1)+j )
                     SForce(6*(p-1)+k) = SForce(6*(p-1)+k) + Weight * Stress(i,j) * Basis(p)
                  END DO
               END DO
            END IF
         END DO
      END DO
      
      CALL DefaultUpdateEquations( Mass, Force )
      
      IF (CalculateStrains) THEN
         DO p=1,nd
            l = Permutation(Indeces(p))
            DO i=1,3
               DO j=i,3
                  k = Ind(3*(i-1)+j)
                  ForceG(6*(l-1)+k) = ForceG(6*(l-1)+k) + FORCE(6*(p-1)+k)
               END DO
            END DO
         END DO
      END IF

      IF (CalcStressAll) THEN
         DO p=1,nd
            l = Permutation(Indeces(p))
            DO i=1,3
               DO j=i,3
                  k = Ind(3*(i-1)+j)
                  SForceG(6*(l-1)+k) = SForceG(6*(l-1)+k) + SFORCE(6*(p-1)+k)
               END DO
            END DO
         END DO
      END IF

   END DO

   Factorize = GetLogical( SolverParams, 'Linear System Refactorize', FoundFactorize )
   FreeFactorize = GetLogical( SolverParams, &
        'Linear System Free Factorization', FoundFreeFactorize )

   CALL ListAddLogical( SolverParams, 'Linear System Refactorize', .FALSE. )
   CALL ListAddLogical( SolverParams, 'Linear System Free Factorization', .FALSE. )   

   !----------------------------------------------------------------------
   ! Linear solves componentwise...
   !-----------------------------------------------------------------------
   IF (CalculateStrains) THEN
     CALL Info('ElasticSolve','Calculating strain components',Level=7)
      DO i=1,3
         DO j=i,3
           CALL Info('ElasticSolve','Component: '//TRIM(I2S(i))//TRIM(I2S(j)), Level=10 )
            
           k = IND(3*(i-1)+j)

            StSolver % Matrix % RHS = ForceG(k::6)
            DO l=1,SIZE( Permutation )
               IF ( Permutation(l) <= 0 ) CYCLE
               StSolver % Variable % Values(Permutation(l)) = NodalStrain(6*(Perm(l)-1)+k)            
            END DO

            ! Solving the strain component
            res = DefaultSolve()

            DO l=1,SIZE( Permutation )
               IF ( Permutation(l) <= 0 ) CYCLE
               NodalStrain(6*(Perm(l)-1)+k) = StSolver % Variable % Values(Permutation(l))
            END DO

         END DO
      END DO
   END IF

   IF (CalcStressAll) THEN
     CALL Info('ElasticSolve','Calculating stress components',Level=7)
      DO i=1,3
         DO j=i,3
           CALL Info('ElasticSolve','Component: '//TRIM(I2S(i))//TRIM(I2S(j)), Level=10 )

            k = IND(3*(i-1)+j)

            StSolver % Matrix % RHS = SForceG(k::6)
            DO l=1,SIZE( Permutation )
               IF ( Permutation(l) <= 0 ) CYCLE
               StSolver % Variable % Values(Permutation(l)) = NodalStress(6*(Perm(l)-1)+k)            
            END DO

            ! Solving the stress component
            res = DefaultSolve()

            DO l=1,SIZE( Permutation )
               IF ( Permutation(l) <= 0 ) CYCLE
               NodalStress(6*(Perm(l)-1)+k) = StSolver % Variable % Values(Permutation(l))
            END DO

         END DO
      END DO

      ! Von Mises stress from the component nodal values:
      ! -------------------------------------------------
      VonMises = 0
      DO i=1,SIZE( Perm )
        IF ( Perm(i) <= 0 ) CYCLE
        
        p = 0
        DO j=1,3
          DO k=1,3
            p = p + 1
            q = 6 * (Perm(i)-1) + IND(p)
            Stress(j,k) = NodalStress(q)
          END DO
        END DO
        
        Stress(:,:) = Stress(:,:) - TRACE(Stress(:,:),3) * Identity/3
        
        DO j=1,3
          DO k=1,3
            VonMises(Perm(i)) = VonMises(Perm(i)) + Stress(j,k)**2
          END DO
        END DO
      END DO

      VonMises = SQRT( 3.0d0 * VonMises / 2.0d0 )
   END IF
   
   IF ( FoundFactorize ) THEN
      CALL ListAddLogical( SolverParams, 'Linear System Refactorize', Factorize )
   ELSE
      CALL ListRemove( SolverParams, 'Linear System Refactorize' )
   END IF

   IF ( .NOT. FoundFreeFactorize ) THEN
      CALL ListRemove( SolverParams, 'Linear System Free Factorization' )
   ELSE
      CALL ListAddLogical( SolverParams, 'Linear System Free Factorization', FreeFactorize )
   END IF



   !Principal stresses and Tresca
   IF(CalcPrincipalAll) THEN
     CALL Info('ElasticSolver','Calculating principal stresses',Level=7)
     DO i=1,SIZE( Perm )
       IF ( Perm(i) <= 0 ) CYCLE       
       !Stresses: 
       p = 0
       DO j=1,3
         DO k=1,3 ! TODO only upper triangle should be filled, this is is wasteful
           p = p+1
           q = 6 * (Perm(i)-1) + IND(p)
           PriCache(j,k) = NodalStress(q)
         END DO
       END DO
       !Use lapack function to do solve eigenvalues (i.e. principal stresses)
       CALL DSYEV( 'N', 'U', 3, PriCache, 3, PriW, PriWork, PriLWork, PriInfo )
       IF (PriInfo /= 0) THEN !error in dsyev
         PriW = 0; !we probably should put NaN in error
       END IF              

       DO l=1,3
         ! eigenvalues are returned in opposite order 
         PrincipalStress(3 * (Perm(i)-1 )+l) = PriW(4-l)                        
       END DO

       IF (CalcPrincipalAngle) THEN
         !DSYEV has changed the vector, so well copy it again from NodalStress
         p=0
         DO j=1,3
           DO k=1,3 ! TODO only upper triangle should be filled, this is is wasteful
              p = p+1
              q = 6 * (Perm(i)-1) + IND(p)
              PriCache(j,k) = NodalStress(q)
           END DO
         END DO

         DO k=1,3 ! for all principal stresses
           ! This is where things get _very_ heary. The code below
           ! solves the following equation system:
           !   (s11-p)v1 + s12*v2 + s13*v3=0
           !   s12*v1    + (s22-p)*v2 + s23*v3=0
           !   v1**2 + v2**2 + v3**2 = 1
           !   where v1...3 are the directional cosines of the primary stresses,
           !   sij are the stress matrix components and
           !   p   is the primary stress in question  
           ! The code is practically unreadable.
           ! This code unit has been tested with the non-trivial
           ! known solutions from following textbooks:
           !   Pennala, E. 1992. Lujuusopin Perusteet
           !   Shames, I. H., Cozzarelli, F., A. Elastic and inelastic stress analysis
           PriAngT1 =( PriCache(1,2) + &
              ((PriCache(2,2)-PriW(4-k)) * (PriCache(1,1)-PriW(4-k))) / &
              (-PriCache(1,2) ) ) / & 
             (((PriCache(2,2)-PriW(4-k))*PriCache(1,3))/&
               PriCache(1,2) - PriCache(2,3) )
           PriAngT2 =(PriCache(1,1)-PriW(4-k))/(PriCache(1,2)) + &
                  PriAngT1*PriCache(1,3)/PriCache(1,2)
           PriAngV(1) = (1/(1+PriAngT1**2 + PriAngT2**2))**0.5
           PriAngV(2) = -PriAngT2 * PriAngV(1)
           PriAngV(3) = PriAngT1 * PriAngV(1)

           PrincipalAngle(9 * (Perm(i)-1 ) +3*(k-1) + 1)    = &
                       (ACOS(PriAngV(1)) ) !angle in radians *360/6.28
           PrincipalAngle(9 * (Perm(i)-1 ) +3*(k-1) + 2) = &
                       (ACOS(PriAngV(2)) ) !angle in radians *360/6.28
           PrincipalAngle(9 * (Perm(i)-1 ) +3*(k-1) + 3) = &
                       (ACOS(PriAngV(3)) ) !angle in radians *360/6.28                              
         END DO
       END IF

       !Tresca                        
       Tresca(Perm(i)) = (PrincipalStress(3*(Perm(i)-1) +1) - &
                    PrincipalStress(3*(Perm(i)-1) +2))/2
       PriTmp = (PrincipalStress(3*(Perm(i)-1) +2) - &
                    PrincipalStress(3*(Perm(i)-1) +3))/2
       IF (PriTmp > Tresca(Perm(i)) ) Tresca(Perm(i)) = PriTmp

       PriTmp = (PrincipalStress(3*(Perm(i)-1) +1) - &
                    PrincipalStress(3*(Perm(i)-1) +3))/2
       IF (PriTmp > Tresca(Perm(i)) ) Tresca(Perm(i)) = PriTmp
       
       !Strain:
       IF(CalculateStrains)THEN
         p = 0
         DO j=1,3
           DO k=1,3 ! TODO only upper triangle should be filled, this is is wasteful
             p = p+1
             q = 6 * (Perm(i)-1) + IND(p)
             PriCache(j,k) = NodalStrain(q)
           END DO
         END DO
   
         !Use lapack function to do solve eigenvalues
         CALL DSYEV( 'N', 'U', 3, PriCache, 3, PriW, PriWork, PriLWork, PriInfo )
         IF(PriInfo /= 0) PriW = 0;
         DO l=1,3
           ! eigenvalues are returned in opposite order 
           PrincipalStrain(3 * (Perm(i)-1 )+l) = PriW(4-l)
         END DO
       END IF ! CalculateStrains
     END DO
   END IF ! Calculate Principal

   DEALLOCATE( Indeces, &
        LocalDisplacement, &
        MASS, &
        FORCE, &
        SForce, &
        Basis, &
        dBasisdx,&
        NodalLame1, &
        NodalLame2 )  

   Model % Solver => Solver

   CALL ListSetNameSpace('')

   CALL Info('ElasticSolve','Finished postprocessing',Level=7)

!--------------------------------------------------------------------------------
 END SUBROUTINE ComputeStressAndStrain
!--------------------------------------------------------------------------------




!------------------------------------------------------------------------------
 FUNCTION TRACE(A,N) RESULT(B)
!------------------------------------------------------------------------------
   IMPLICIT NONE
   DOUBLE PRECISION :: A(:,:),B
   INTEGER :: N
!------------------------------------------------------------------------------
   INTEGER :: I
!------------------------------------------------------------------------------
   B = 0.0D0
   DO i = 1,N
      B = B + A(i,i)
   END DO
!------------------------------------------------------------------------------
 END FUNCTION TRACE
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
 FUNCTION DDOT_PRODUCT(A,B,N) RESULT(C)
!------------------------------------------------------------------------------
   IMPLICIT NONE
   DOUBLE PRECISION :: A(:,:),B(:,:),C
   INTEGER :: N
!------------------------------------------------------------------------------
   INTEGER :: I,J
!------------------------------------------------------------------------------
   C = 0.0D0
   DO I = 1,N
      DO J = 1,N
         C = C + A(I,J)*B(I,J)
      END DO
   END DO
!------------------------------------------------------------------------------
 END FUNCTION DDOT_PRODUCT
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE ElasticSolver
!------------------------------------------------------------------------------





!------------------------------------------------------------------------------
   FUNCTION ElastBoundaryResidual( Model, Edge, Mesh, Quant, Perm, Gnorm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE DefUtils
     IMPLICIT NONE
!------------------------------------------------------------------------------
     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2), Gnorm
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Edge
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes, EdgeNodes
     TYPE(Element_t), POINTER :: Element, Bndry

     INTEGER :: i,j,k,n,l,t,dim,DOFs,Pn,En
     LOGICAL :: stat, GotIt

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
     REAL(KIND=dp) :: Normal(3), EdgeLength
     REAL(KIND=dp) :: u, v, w, s, detJ
     REAL(KIND=dp) :: Residual(3), ResidualNorm, Area
     REAL(KIND=dp) :: Dir(3)

     REAL(KIND=dp) :: Displacement(3)
     REAL(KIND=dp) :: YoungsModulus
     REAL(KIND=dp) :: PoissonRatio
     REAL(KIND=dp) :: Density
     REAL(KIND=dp) :: Temperature
     REAL(KIND=dp) :: Lame1
     REAL(KIND=dp) :: Lame2
     REAL(KIND=dp) :: Damping
     REAL(KIND=dp) :: HeatExpansionCoeff
     REAL(KIND=dp) :: ReferenceTemperature
     REAL(KIND=dp) :: Identity(3,3), YoungsAverage
     REAL(KIND=dp) :: Grad(3,3), DefG(3,3), Strain(3,3), Stress1(3,3), Stress2(3,3)

     REAL(KIND=dp), ALLOCATABLE :: Basis(:),dBasisdx(:,:), ddBasisddx(:,:,:)
     REAL(KIND=dp), ALLOCATABLE :: EdgeBasis(:), dEdgeBasisdx(:,:)
     REAL(KIND=dp), ALLOCATABLE :: x(:), y(:), z(:), ExtPressure(:)
     REAL(KIND=dp), ALLOCATABLE :: Force(:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDisplacement(:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalYoungsModulus(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDensity(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalTemperature(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalLame1(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalLame2(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDamping(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalPoissonRatio(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalHeatExpansionCoeff(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalReferenceTemperature(:)

     LOGICAL :: PlaneStress
     INTEGER :: eq_id
     TYPE(ValueList_t), POINTER :: Material
     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
!------------------------------------------------------------------------------

!    Initialize:
!    -----------
     Indicator = 0.0d0
     Gnorm = 0.0d0

     Identity = 0.0d0
     DO i=1,3
        Identity(i,i) = 1.0d0
     END DO

     Metric = 0.0d0
     DO i=1,3
        Metric(i,i) = 1.0d0
     END DO

     SELECT CASE( CurrentCoordinateSystem() )
        CASE( AxisSymmetric, CylindricSymmetric )
           dim = 3
        CASE DEFAULT
           dim = CoordinateSystemDimension()
     END SELECT

     DOFs = dim
     IF ( CurrentCoordinateSystem() == AxisSymmetric ) DOFs = DOFs-1
!    
!    --------------------------------------------------
     Element => Edge % BoundaryInfo % Left

     IF ( .NOT. ASSOCIATED( Element ) ) THEN

        Element => Edge % BoundaryInfo % Right

     ELSE IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) THEN

        Element => Edge % BoundaryInfo % Right

     END IF

     IF ( .NOT. ASSOCIATED( Element ) ) RETURN
     IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) RETURN

     En = Edge % TYPE % NumberOfNodes
     Pn = Element % TYPE % NumberOfNodes

     ALLOCATE( EdgeNodes % x(En), EdgeNodes % y(En), EdgeNodes % z(En) )

     EdgeNodes % x = Mesh % Nodes % x(Edge % NodeIndexes)
     EdgeNodes % y = Mesh % Nodes % y(Edge % NodeIndexes)
     EdgeNodes % z = Mesh % Nodes % z(Edge % NodeIndexes)

     ALLOCATE( Nodes % x(Pn), Nodes % y(Pn), Nodes % z(Pn) )

     Nodes % x = Mesh % Nodes % x(Element % NodeIndexes)
     Nodes % y = Mesh % Nodes % y(Element % NodeIndexes)
     Nodes % z = Mesh % Nodes % z(Element % NodeIndexes)

     ALLOCATE( x(En), y(En), z(En), EdgeBasis(En), dEdgeBasisdx(En,3),         &
       Basis(Pn), dBasisdx(Pn,3), Force(3,En), ExtPressure(En),                &
       NodalDisplacement(3,Pn), NodalYoungsModulus(En), Nodaldensity(En),      &
       NodalTemperature(Pn), NodalLame1(En), NodalLame2(En), NodalDamping(Pn), &
       NodalPoissonRatio(En), NodalHeatExpansionCOeff(En),                     &
       NodalReferenceTemperature(En) )

     DO l = 1,En
       DO k = 1,Pn
          IF ( Edge % NodeIndexes(l) == Element % NodeIndexes(k) ) THEN
             x(l) = Element % TYPE % NodeU(k)
             y(l) = Element % TYPE % NodeV(k)
             z(l) = Element % TYPE % NodeW(k)
             EXIT
          END IF
       END DO
     END DO
!
!    Integrate square of residual over boundary element:
!    ---------------------------------------------------
     Indicator     = 0.0d0
     EdgeLength    = 0.0d0
     YoungsAverage = 0.0d0
     ResidualNorm  = 0.0d0

     DO j=1,Model % NumberOfBCs
        IF ( Edge % BoundaryInfo % Constraint /= Model % BCs(j) % Tag ) CYCLE

!        IF ( .NOT. ListGetLogical( Model % BCs(j) % Values, &
!                  'Flow Force BC', gotIt ) ) CYCLE

!
!       Logical parameters:
!       -------------------
        eq_id = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Equation', &
             minv=1, maxv=Model % NumberOfEquations )
        PlaneStress = ListGetLogical( Model % Equations(eq_id) % Values,'Plane Stress',GotIt )
!
!       Material parameters:
!       --------------------
        k = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Material', &
                minv=1, maxv=Model % NumberOFMaterials )
        Material => Model % Materials(k) % Values
        NodalYoungsModulus(1:En) = ListGetReal( Material,'Youngs Modulus', &
             En, Edge % NodeIndexes, GotIt )
        NodalPoissonRatio(1:En) = ListGetReal( Material, 'Poisson Ratio', &
             En, Edge % NodeIndexes, GotIt )
        NodalTemperature(1:En) = ListGetReal( Material,'Temperature', &
             En, Edge % NodeIndexes, GotIt )
        NodalReferenceTemperature(1:En) = ListGetReal( Material,'Reference Temperature', &
             En, Edge % NodeIndexes, GotIt )
        NodalDensity(1:En) = ListGetReal( Material,'Density',En,Edge % NodeIndexes, GotIt )
        NodalDamping(1:En) = ListGetReal( Material,'Damping',En,Edge % NodeIndexes, GotIt )
        HeatExpansionCoeff   = 0.0D0
        
        IF ( PlaneStress ) THEN
           NodalLame1(1:En) = NodalYoungsModulus(1:En) * NodalPoissonRatio(1:En) /  &
                ( (1.0d0 - NodalPoissonRatio(1:En)**2) )
        ELSE
           NodalLame1(1:En) = NodalYoungsModulus(1:En) * NodalPoissonRatio(1:En) /  &
                (  (1.0d0 + NodalPoissonRatio(1:En)) * ( 1.0d0 - 2.0d0*NodalPoissonRatio(1:En) ) )
        END IF

        NodalLame2(1:En) = NodalYoungsModulus(1:En)  / ( 2.0d0*(1.0d0 + NodalPoissonRatio(1:En) ) )
!
!       Given traction:
!       ---------------
        Force = 0.0d0

        Force(1,1:En) = ListGetReal( Model % BCs(j) % Values, &
            'Force 1', En, Edge % NodeIndexes, GotIt )

        Force(2,1:En) = ListGetReal( Model % BCs(j) % Values, &
            'Force 2', En, Edge % NodeIndexes, GotIt )

        Force(3,1:En) = ListGetReal( Model % BCs(j) % Values, &
            'Force 3', En, Edge % NodeIndexes, GotIt )

!       Force in normal direction:
!       ---------------------------
        ExtPressure(1:En) = ListGetReal( Model % BCs(j) % Values, &
          'Normal Force', En, Edge % NodeIndexes, GotIt )

!       If dirichlet BC for displacement in any direction given,
!       nullify force in that directon:
!       ------------------------------------------------------------------
        Dir = 1.0d0
        s = ListGetConstReal( Model % BCs(j) % Values, 'Displacement 1', GotIt )
        IF ( GotIt ) Dir(1) = 0

        s = ListGetConstReal( Model % BCs(j) % Values, 'Displacement 2', GotIt )
        IF ( GotIt ) Dir(2) = 0

        s = ListGetConstReal( Model % BCs(j) % Values, 'Displacement 3', GotIt )
        IF ( GotIt ) Dir(3) = 0
!
!       Elementwise nodal solution:
!       ---------------------------
        NodalDisplacement = 0.0d0
        DO k=1,DOFs
           NodalDisplacement(k,1:Pn) = Quant( DOFs*Perm(Element % NodeIndexes)-DOFs+k )
        END DO
!
!       Integration:
!       ------------
        EdgeLength    = 0.0d0
        YoungsAverage = 0.0d0
        ResidualNorm  = 0.0d0

        IntegStuff = GaussPoints( Edge )

        DO t=1,IntegStuff % n
           u = IntegStuff % u(t)
           v = IntegStuff % v(t)
           w = IntegStuff % w(t)

           stat = ElementInfo( Edge, EdgeNodes, u, v, w, detJ, &
               EdgeBasis, dEdgeBasisdx )

           IF ( CurrentCoordinateSystem() == Cartesian ) THEN
              s = IntegStuff % s(t) * detJ
           ELSE
              u = SUM( EdgeBasis(1:En) * EdgeNodes % x(1:En) )
              v = SUM( EdgeBasis(1:En) * EdgeNodes % y(1:En) )
              w = SUM( EdgeBasis(1:En) * EdgeNodes % z(1:En) )
      
              CALL CoordinateSystemInfo( Metric, SqrtMetric, &
                          Symb, dSymb, u, v, w )

              s = IntegStuff % s(t) * detJ * SqrtMetric
           END IF

           Normal = NormalVector( Edge, EdgeNodes, u, v, .TRUE. )

           u = SUM( EdgeBasis(1:En) * x(1:En) )
           v = SUM( EdgeBasis(1:En) * y(1:En) )
           w = SUM( EdgeBasis(1:En) * z(1:En) )

           stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
              Basis, dBasisdx )

           Lame1 = SUM( NodalLame1(1:En) * EdgeBasis(1:En) )
           Lame2 = SUM( NodalLame2(1:En) * EdgeBasis(1:En) )
!
!          Stress tensor on the edge:
!          --------------------------
           Grad = MATMUL( NodalDisplacement(:,1:Pn),dBasisdx(1:Pn,:) )
           DefG = Identity + Grad
           Strain = (TRANSPOSE(Grad)+Grad+MATMUL(TRANSPOSE(Grad),Grad))/2.0D0
           Stress2 = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,dim)*Identity
           Stress1 = MATMUL(DefG,Stress2)
!
!          Given force at the integration point:
!          -------------------------------------
           Residual = 0.0d0
           Residual = MATMUL( Force(:,1:En), EdgeBasis(1:En) ) - &
                 SUM( ExtPressure(1:En) * EdgeBasis(1:En) ) * Normal

           Residual = Residual - MATMUL( Stress1, Normal ) * Dir

           EdgeLength   = EdgeLength + s
           ResidualNorm = ResidualNorm + s * SUM( Residual(1:dim) ** 2 )
           YoungsAverage = YoungsAverage + &
                   s * SUM( NodalYoungsModulus(1:En) * EdgeBasis(1:En) )
        END DO
        EXIT
     END DO

     IF ( YoungsAverage > AEPS ) THEN
        YoungsAverage = YoungsAverage / EdgeLength
        Indicator = EdgeLength * ResidualNorm / YoungsAverage
     END IF

     DEALLOCATE( Nodes % x, Nodes % y, Nodes % z)
     DEALLOCATE( EdgeNodes % x, EdgeNodes % y, EdgeNodes % z)

     DEALLOCATE( x, y, z, EdgeBasis, dEdgeBasisdx, Basis, dBasisdx,  &
      Force, ExtPressure, NodalDisplacement, NodalYoungsModulus,     &
      Nodaldensity, NodalTemperature, NodalLame1, NodalLame2, NodalDamping, &
      NodalPoissonRatio, NodalHeatExpansionCOeff, NodalReferenceTemperature )

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION TRACE(A,N) RESULT(B)
!------------------------------------------------------------------------------
    IMPLICIT NONE
    DOUBLE PRECISION :: A(:,:),B
    INTEGER :: N
!------------------------------------------------------------------------------
    INTEGER :: I
!------------------------------------------------------------------------------
    B = 0.0D0
    DO i = 1,N
       B = B + A(i,i)
    END DO
!------------------------------------------------------------------------------
  END FUNCTION TRACE
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   END FUNCTION ElastBoundaryResidual
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  FUNCTION ElastEdgeResidual( Model,Edge,Mesh,Quant,Perm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE DefUtils
     IMPLICIT NONE

     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2)
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Edge
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes, EdgeNodes
     TYPE(Element_t), POINTER :: Element, Bndry

     INTEGER :: i,j,k,l,n,t,dim,DOFs,En,Pn
     LOGICAL :: stat, GotIt

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
     REAL(KIND=dp) :: Stress(3,3,2), Jump(3), Identity(3,3)
     REAL(KIND=dp) :: Normal(3)
     REAL(KIND=dp) :: Displacement(3)
     REAL(KIND=dp) :: YoungsModulus
     REAL(KIND=dp) :: PoissonRatio
     REAL(KIND=dp) :: Density
     REAL(KIND=dp) :: Temperature
     REAL(KIND=dp) :: Lame1
     REAL(KIND=dp) :: Lame2
     REAL(KIND=dp) :: Damping
     REAL(KIND=dp) :: HeatExpansionCoeff
     REAL(KIND=dp) :: ReferenceTemperature
     REAL(KIND=dp) :: YoungsAverage
     REAL(KIND=dp) :: u, v, w, s, detJ
     REAL(KIND=dp) :: Residual, ResidualNorm, EdgeLength
     REAL(KIND=dp) :: Grad(3,3), DefG(3,3), Strain(3,3), Stress1(3,3), Stress2(3,3)

     LOGICAL :: PlaneStress
     INTEGER :: eq_id
     TYPE(ValueList_t), POINTER :: Material

     REAL(KIND=dp), ALLOCATABLE :: dBasisdx(:,:), ddBasisddx(:,:,:)
     REAL(KIND=dp), ALLOCATABLE :: EdgeBasis(:), Basis(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDisplacement(:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalYoungsModulus(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalPoissonRatio(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDensity(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalTemperature(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalLame1(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalLame2(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDamping(:)
     REAL(KIND=dp), ALLOCATABLE :: x(:), y(:), z(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalHeatExpansionCoeff(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalReferenceTemperature(:)

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
!------------------------------------------------------------------------------

!    Initialize:
!    -----------
     SELECT CASE( CurrentCoordinateSystem() )
        CASE( AxisSymmetric, CylindricSymmetric )
           dim = 3
        CASE DEFAULT
           dim = CoordinateSystemDimension()
     END SELECT

     DOFs = dim
     IF ( CurrentCoordinateSystem() == AxisSymmetric ) DOFs = DOFs - 1

     Metric = 0.0d0
     Identity = 0.0d0
     DO i = 1,3
        Metric(i,i) = 1.0d0
        Identity(i,i) = 1.0d0
     END DO
!
!    ---------------------------------------------
     Element => Edge % BoundaryInfo % Left
     n = Element % TYPE % NumberOfNodes

     Element => Edge % BoundaryInfo % Right
     n = MAX( n, Element % TYPE % NumberOfNodes )

     ALLOCATE( Nodes % x(n), Nodes % y(n), Nodes % z(n) )

     En = Edge % TYPE % NumberOfNodes
     ALLOCATE( EdgeNodes % x(En), EdgeNodes % y(En), EdgeNodes % z(En) )

     EdgeNodes % x = Mesh % Nodes % x(Edge % NodeIndexes)
     EdgeNodes % y = Mesh % Nodes % y(Edge % NodeIndexes)
     EdgeNodes % z = Mesh % Nodes % z(Edge % NodeIndexes)

     ALLOCATE( Basis(n), EdgeBasis(En), dBasisdx(n,3), x(En), y(En), z(En),   &
       NodalDisplacement(3,n), NodalYoungsModulus(En), NodalPoissonRatio(En), &
       NodalDensity(en), NodalTemperature(n), NodalLame1(En), NodalLame2(En), &
       NodalDamping(En), NodalHeatExpansionCoeff(En), NodalReferenceTemperature(En) )


!    Integrate square of jump over edge:
!    ------------------------------------
     ResidualNorm  = 0.0d0
     EdgeLength    = 0.0d0
     Indicator     = 0.0d0
     Grad          = 0.0d0
     YoungsAverage = 0.0d0

     IntegStuff = GaussPoints( Edge )

     DO t=1,IntegStuff % n

        u = IntegStuff % u(t)
        v = IntegStuff % v(t)
        w = IntegStuff % w(t)

        stat = ElementInfo( Edge, EdgeNodes, u, v, w, detJ, &
             EdgeBasis, dBasisdx )

        Normal = NormalVector( Edge, EdgeNodes, u, v, .FALSE. )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           s = IntegStuff % s(t) * detJ
        ELSE
           u = SUM( EdgeBasis(1:En) * EdgeNodes % x(1:En) )
           v = SUM( EdgeBasis(1:En) * EdgeNodes % y(1:En) )
           w = SUM( EdgeBasis(1:En) * EdgeNodes % z(1:En) )

           CALL CoordinateSystemInfo( Metric, SqrtMetric, &
                       Symb, dSymb, u, v, w )
           s = IntegStuff % s(t) * detJ * SqrtMetric
        END IF

        Stress = 0.0d0
        DO i = 1,2
           IF ( i==1 ) THEN
              Element => Edge % BoundaryInfo % Left
           ELSE
              Element => Edge % BoundaryInfo % Right
           END IF

           IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) CYCLE

           Pn = Element % TYPE % NumberOfNodes
           Nodes % x(1:Pn) = Mesh % Nodes % x(Element % NodeIndexes)
           Nodes % y(1:Pn) = Mesh % Nodes % y(Element % NodeIndexes)
           Nodes % z(1:Pn) = Mesh % Nodes % z(Element % NodeIndexes)

           DO j = 1,En
              DO k = 1,Pn
                 IF ( Edge % NodeIndexes(j) == Element % NodeIndexes(k) ) THEN
                    x(j) = Element % TYPE % NodeU(k)
                    y(j) = Element % TYPE % NodeV(k)
                    z(j) = Element % TYPE % NodeW(k)
                    EXIT
                 END IF
              END DO
           END DO

           u = SUM( EdgeBasis(1:En) * x(1:En) )
           v = SUM( EdgeBasis(1:En) * y(1:En) )
           w = SUM( EdgeBasis(1:En) * z(1:En) )

           stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
               Basis, dBasisdx )
!
!          Logical parameters:
!          -------------------
           eq_id = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Equation', &
                  minv=1, maxv=Model % NumberOFEquations )

           PlaneStress = ListGetLogical( Model % Equations(eq_id) % Values,'Plane Stress',GotIt )
!
!          Material parameters:
!          --------------------
           k = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Material', &
                  minv=1, maxv=Model % NumberOfMaterials )

           Material => Model % Materials(k) % Values

           NodalYoungsModulus(1:En) = ListGetReal( Material,'Youngs Modulus', &
                En, Edge % NodeIndexes, GotIt )
           YoungsModulus = SUM( NodalYoungsModulus(1:En) * EdgeBasis(1:En) )

           NodalPoissonRatio(1:En) = ListGetReal( Material, 'Poisson Ratio', &
                En, Edge % NodeIndexes, GotIt )
           PoissonRatio = SUM( NodalPoissonRatio(1:En) * EdgeBasis(1:En) )

           NodalTemperature(1:En) = ListGetReal( Material,'Temperature', &
                En, Edge % NodeIndexes, GotIt )
           Temperature = SUM( NodalTemperature(1:En) * EdgeBasis(1:En) )

           NodalReferenceTemperature(1:En) = ListGetReal( Material,'Reference Temperature', &
                En, Edge % NodeIndexes, GotIt )
           ReferenceTemperature = SUM( NodalReferenceTemperature(1:En) * EdgeBasis(1:En) )

           NodalDensity(1:En) = ListGetReal( Material,'Density',En,Edge % NodeIndexes, GotIt )
           Density = SUM( NodalDensity(1:En) * EdgeBasis(1:En) )

           NodalDamping(1:En) = ListGetReal( Material,'Damping',En,Edge % NodeIndexes, GotIt )
           Damping = SUM( NodalDamping(1:En) * EdgeBasis(1:En) )

           HeatExpansionCoeff   = 0.0D0

           IF ( PlaneStress ) THEN
              NodalLame1(1:En) = NodalYoungsModulus(1:En) * NodalPoissonRatio(1:En) /  &
                   ( (1.0d0 - NodalPoissonRatio(1:En)**2) )
           ELSE
              NodalLame1(1:En) = NodalYoungsModulus(1:En) * NodalPoissonRatio(1:En) /  &
                   (  (1.0d0 + NodalPoissonRatio(1:En)) * ( 1.0d0 - 2.0d0*NodalPoissonRatio(1:En) ) )
           END IF

           NodalLame2(1:En) = NodalYoungsModulus(1:En)  / ( 2.0d0*(1.0d0 + NodalPoissonRatio(1:En) ) )

           Lame1 = SUM( NodalLame1(1:En) * EdgeBasis(1:En) )
           Lame2 = SUM( NodalLame2(1:En) * EdgeBasis(1:En) )
!
!          Elementwise nodal solution:
!          ---------------------------
           NodalDisplacement = 0.0d0
           DO k=1,DOFs
              NodalDisplacement(k,1:Pn) = Quant( DOFs*Perm(Element % NodeIndexes)-DOFs+k )
           END DO
!
!          Stress tensor on the edge:
!          --------------------------
           Grad = MATMUL(NodalDisplacement(:,1:Pn),dBasisdx(1:Pn,:) )
           DefG = Identity + Grad
           Strain = (TRANSPOSE(Grad)+Grad+MATMUL(TRANSPOSE(Grad),Grad))/2.0D0
           Stress2 = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,dim)*Identity
           Stress1 = MATMUL(DefG,Stress2)
           Stress(:,:,i) = Stress1

        END DO

        EdgeLength  = EdgeLength + s
        Jump = MATMUL( ( Stress(:,:,1) - Stress(:,:,2)), Normal )
        ResidualNorm = ResidualNorm + s * SUM( Jump(1:dim) ** 2 )

        YoungsAverage = YoungsAverage + s * YoungsModulus

     END DO

     YoungsAverage = YoungsAverage / EdgeLength
     Indicator = EdgeLength * ResidualNorm / YoungsAverage

     DEALLOCATE( Nodes % x, Nodes % y, Nodes % z)
     DEALLOCATE( EdgeNodes % x, EdgeNodes % y, EdgeNodes % z)

     DEALLOCATE( Basis, EdgeBasis, dBasisdx, x, y, z,   &
       NodalDisplacement, NodalYoungsModulus, NodalPoissonRatio,  &
       NodalDensity, NodalTemperature, NodalLame1, NodalLame2,    &
       NodalDamping, NodalHeatExpansionCoeff, NodalReferenceTemperature )

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION TRACE(A,N) RESULT(B)
!------------------------------------------------------------------------------
    IMPLICIT NONE
    DOUBLE PRECISION :: A(:,:),B
    INTEGER :: N
!------------------------------------------------------------------------------
    INTEGER :: I
!------------------------------------------------------------------------------
    B = 0.0D0
    DO i = 1,N
       B = B + A(i,i)
    END DO
!------------------------------------------------------------------------------
  END FUNCTION TRACE
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   END FUNCTION ElastEdgeResidual
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION ElastInsideResidual( Model, Element,  &
                      Mesh, Quant, Perm, Fnorm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE DefUtils
!------------------------------------------------------------------------------
     IMPLICIT NONE
!------------------------------------------------------------------------------
     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2), Fnorm
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Element
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes

     INTEGER :: i,j,k,l,m,n,t,dim,DOFs

     LOGICAL :: stat, GotIt

     TYPE( Variable_t ), POINTER :: Var


     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)

     REAL(KIND=dp) :: Density
     REAL(KIND=dp) :: YoungsModulus
     REAL(KIND=dp) :: PoissonRatio
     REAL(KIND=dp) :: Lame1
     REAL(KIND=dp) :: Lame2
     REAL(KIND=dp) :: Damping
     REAL(KIND=dp) :: HeatExpansionCoeff
     REAL(KIND=dp) :: ReferenceTemperature
     REAL(KIND=dp) :: Displacement(3),Identity(3,3)
     REAL(KIND=dp) :: Grad(3,3), DefG(3,3), Strain(3,3), Stress1(3,3), Stress2(3,3)
     REAL(KIND=dp) :: YoungsAverage, Energy
     REAL(KIND=dp) :: Temperature

     REAL(KIND=dp), ALLOCATABLE :: NodalDensity(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalYoungsModulus(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalPoissonRatio(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalLame1(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalLame2(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDamping(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDisplacement(:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalHeatExpansionCoeff(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalReferenceTemperature(:)
     REAL(KIND=dp), ALLOCATABLE :: Stress(:,:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalTemperature(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalForce(:,:), Veloc(:,:), Accel(:,:)
     REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:)

     INTEGER :: eq_id

     LOGICAL :: PlaneStress, Transient

     REAL(KIND=dp) :: u, v, w, s, detJ
     REAL(KIND=dp), POINTER :: Gravity(:,:)
     REAL(KIND=dp) :: Residual(3), ResidualNorm, Area

     TYPE(ValueList_t), POINTER :: Material

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
!------------------------------------------------------------------------------

!    Initialize:
!    -----------
     Fnorm = 0.0d0
     Indicator = 0.0d0

     IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) RETURN

     Metric = 0.0d0
     DO i=1,3
        Metric(i,i) = 1.0d0
     END DO

     SELECT CASE( CurrentCoordinateSystem() )
        CASE( AxisSymmetric, CylindricSymmetric )
           dim = 3
        CASE DEFAULT
           dim = CoordinateSystemDimension()
     END SELECT

     DOFs = dim 
     IF ( CurrentCoordinateSystem() == AxisSymmetric ) DOFs = DOFs-1
!
!    Element nodal points:
!    ---------------------
     n = Element % TYPE % NumberOfNodes

     ALLOCATE( Nodes % x(n), Nodes % y(n), Nodes % z(n), NodalDensity(n), &
      NodalYoungsModulus(n), NodalPoissonRatio(n), NodalLame1(n), NodalLame2(n), &
      NodalDamping(n), NodalDisplacement(3,n), NodalHeatExpansionCoeff(n), &
      NodalReferenceTemperature(n), Stress(3,3,n), NodalTemperature(n),    &
      NodalForce(3,n), Veloc(3,n), Accel(3,n), Basis(n), dBasisdx(n,3) )

     Nodes % x = Mesh % Nodes % x(Element % NodeIndexes)
     Nodes % y = Mesh % Nodes % y(Element % NodeIndexes)
     Nodes % z = Mesh % Nodes % z(Element % NodeIndexes)
!
!    Logical parameters:
!    -------------------
     eq_id = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Equation', &
              minv=1, maxv=Model % NumberOfEquations )

     PlaneStress = ListGetLogical( Model % Equations(eq_id) % Values, &
          'Plane Stress',GotIt )
!
!    Material parameters:
!    --------------------
     k = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Material', &
             minv=1, maxv=Model % NumberOfMaterials )

     Material => Model % Materials(k) % Values

     NodalYoungsModulus(1:n) = ListGetReal( Material,'Youngs Modulus', &
          n, Element % NodeIndexes, GotIt )

     NodalPoissonRatio(1:n) = ListGetReal( Material, 'Poisson Ratio', &
          n, Element % NodeIndexes, GotIt )

     NodalTemperature(1:n) = ListGetReal( Material,'Temperature', &
          n, Element % NodeIndexes, GotIt )

     NodalReferenceTemperature(1:n) = ListGetReal( Material,'Reference Temperature', &
          n, Element % NodeIndexes, GotIt )

!
!    Check for time dep.
!    -------------------

     IF ( ListGetString( Model % Simulation, 'Simulation Type') == 'transient' ) THEN
        Transient = .TRUE.
        Var => VariableGet( Model % Variables, 'Displacement', .TRUE. )
        DO i=1,DOFs
           Veloc(i,1:n) = Var % PrevValues(DOFs*(Var % Perm(Element % NodeIndexes)-1)+i,1)
           Accel(i,1:n) = Var % PrevValues(DOFs*(Var % Perm(Element % NodeIndexes)-1)+i,2)
        END DO

        NodalDensity(1:n) = ListGetReal( Material,'Density', &
               n, Element % NodeIndexes, GotIt )

        NodalDamping(1:n) = ListGetReal( Material,'Damping', &
               n, Element % NodeIndexes, GotIt )
     ELSE
        Transient = .FALSE.
     END IF

     HeatExpansionCoeff   = 0.0D0

     IF ( PlaneStress ) THEN
        NodalLame1(1:n) = NodalYoungsModulus(1:n) * NodalPoissonRatio(1:n) /  &
             ( (1.0d0 - NodalPoissonRatio(1:n)**2) )
     ELSE
        NodalLame1(1:n) = NodalYoungsModulus(1:n) * NodalPoissonRatio(1:n) /  &
             (  (1.0d0 + NodalPoissonRatio(1:n)) * ( 1.0d0 - 2.0d0*NodalPoissonRatio(1:n) ) )
     END IF

     NodalLame2(1:n) = NodalYoungsModulus(1:n)  / ( 2.0d0*(1.0d0 + NodalPoissonRatio(1:n) ) )
!
!    Elementwise nodal solution:
!    ---------------------------
     NodalDisplacement = 0.0d0
     DO k=1,DOFs
        NodalDisplacement(k,1:n) = Quant( DOFs*Perm(Element % NodeIndexes)-DOFs+k )
     END DO
!
!    Body Forces:
!    ------------
     k = ListGetInteger(Model % Bodies(Element % BodyId) % Values,'Body Force', GotIt, &
                    1, Model % NumberOfBodyForces )

     NodalForce = 0.0d0

     IF ( GotIt .AND. k > 0  ) THEN

        NodalForce(1,1:n) = NodalForce(1,1:n) + ListGetReal( &
             Model % BodyForces(k) % Values, 'Stress BodyForce 1', &
             n, Element % NodeIndexes, GotIt )
        
        NodalForce(2,1:n) = NodalForce(2,1:n) + ListGetReal( &
             Model % BodyForces(k) % Values, 'Stress BodyForce 2', &
             n, Element % NodeIndexes, GotIt )
        
        NodalForce(3,1:n) = NodalForce(3,1:n) + ListGetReal( &
             Model % BodyForces(k) % Values, 'Stress BodyForce 3', &
             n, Element % NodeIndexes, GotIt )

     END IF

     Identity = 0.0D0
     DO i = 1,DIM
        Identity(i,i) = 1.0D0
     END DO
!
!    Values of the stress tensor at node points:
!    -------------------------------------------
     Grad = 0.0d0
     DO i = 1,n
        u = Element % TYPE % NodeU(i)
        v = Element % TYPE % NodeV(i)
        w = Element % TYPE % NodeW(i)

        stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
            Basis, dBasisdx )

        Lame1 = NodalLame1(i)
        Lame2 = NodalLame2(i)

        Grad = 0.0d0
        Grad = MATMUL(NodalDisplacement(:,1:N),dBasisdx(1:N,:) )
        DefG = Identity + Grad
        Strain = (TRANSPOSE(Grad)+Grad+MATMUL(TRANSPOSE(Grad),Grad))/2.0D0
        Stress2 = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,dim)*Identity
        Stress1 = MATMUL(DefG,Stress2)
        Stress(:,:,i) = Stress1

     END DO
!
!    Integrate square of residual over element:
!    ------------------------------------------
     ResidualNorm = 0.0d0
     Fnorm = 0.0d0
     Area = 0.0d0
     Energy = 0.0d0
     YoungsAverage = 0.0d0

     IntegStuff = GaussPoints( Element )

     DO t=1,IntegStuff % n
        u = IntegStuff % u(t)
        v = IntegStuff % v(t)
        w = IntegStuff % w(t)

        stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
            Basis, dBasisdx )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           s = IntegStuff % s(t) * detJ
        ELSE
           u = SUM( Basis(1:n) * Nodes % x(1:n) )
           v = SUM( Basis(1:n) * Nodes % y(1:n) )
           w = SUM( Basis(1:n) * Nodes % z(1:n) )

           CALL CoordinateSystemInfo( Metric, SqrtMetric, Symb, dSymb, u, v, w )
           s = IntegStuff % s(t) * detJ * SqrtMetric
        END IF
!
!       Residual of the diff.equation:
!       ------------------------------
        Residual = 0.0d0
        DO i = 1,Dim
           Residual(i) = SUM( NodalForce(i,1:n) * Basis(1:n) )

           IF ( Transient ) THEN
              Residual(i) = Residual(i) + SUM( NodalDensity(1:n) * Basis(1:n) ) * &
                                 SUM( Accel(i,1:n) * Basis(1:n) )

              Residual(i) = Residual(i) + SUM( NodalDamping(1:n) * Basis(1:n) ) * &
                                 SUM( Veloc(i,1:n) * Basis(1:n) )
           END IF

           DO j = 1,Dim
              DO k = 1,n
                 Residual(i) = Residual(i) + Stress(i,j,k)*dBasisdx(k,j)
              END DO
           END DO
        END DO
!
!       Dual norm of the load:
!       ----------------------
        DO i = 1,Dim
           Fnorm = Fnorm + s * SUM( NodalForce(i,1:n) * Basis(1:n) ) ** 2
        END DO

        YoungsAverage = YoungsAverage + s * SUM( NodalYoungsModulus(1:n) * Basis(1:n) )

!       Energy:
!       -------
        Grad = 0.0d0
        Grad = MATMUL(NodalDisplacement(:,1:N),dBasisdx(1:N,:) )
        DefG = Identity + Grad
        Strain = (TRANSPOSE(Grad)+Grad+MATMUL(TRANSPOSE(Grad),Grad))/2.0D0
        Stress2 = 2.0D0*Lame2*Strain + Lame1*TRACE(Strain,dim)*Identity
        Stress1 = MATMUL(DefG,Stress2)
        Energy = Energy + s*DDOTPROD(Strain,Stress1,Dim)/2.0d0

        Area = Area + s
        ResidualNorm = ResidualNorm + s * SUM( Residual(1:dim) ** 2 )

     END DO

     YoungsAverage = YoungsAverage / Area
     Fnorm = Energy
     Indicator = Area * ResidualNorm / YoungsAverage

     DEALLOCATE( Nodes % x, Nodes % y, Nodes % z, NodalDensity,      &
      NodalYoungsModulus, NodalPoissonRatio, NodalLame1, NodalLame2, &
      NodalDamping, NodalDisplacement, NodalHeatExpansionCoeff,      &
      NodalReferenceTemperature, Stress, NodalTemperature,           &
      NodalForce, Veloc, Accel, Basis, dBasisdx )

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION TRACE(A,N) RESULT(B)
!------------------------------------------------------------------------------
    IMPLICIT NONE
    DOUBLE PRECISION :: A(:,:),B
    INTEGER :: N
!------------------------------------------------------------------------------
    INTEGER :: I
!------------------------------------------------------------------------------
    B = 0.0D0
    DO i = 1,N
       B = B + A(i,i)
    END DO
!------------------------------------------------------------------------------
  END FUNCTION TRACE
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  FUNCTION DDOTPROD(A,B,N) RESULT(C)
!------------------------------------------------------------------------------
    IMPLICIT NONE
    DOUBLE PRECISION :: A(:,:),B(:,:),C
    INTEGER :: N
!------------------------------------------------------------------------------
    INTEGER :: I,J
!------------------------------------------------------------------------------
    C = 0.0D0
    DO i = 1,N
       DO j = 1,N
          C = C + A(i,j)*B(i,j)
       END DO
    END DO
!------------------------------------------------------------------------------
  END FUNCTION DDOTPROD
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   END FUNCTION ElastInsideResidual
!------------------------------------------------------------------------------
