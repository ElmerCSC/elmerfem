!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This library is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU Lesser General Public
! *  License as published by the Free Software Foundation; either
! *  version 2.1 of the License, or (at your option) any later version.
! *
! *  This library is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! *  Lesser General Public License for more details.
! * 
! *  You should have received a copy of the GNU Lesser General Public
! *  License along with this library (in file ../LGPL-2.1); if not, write 
! *  to the Free Software Foundation, Inc., 51 Franklin Street, 
! *  Fifth Floor, Boston, MA  02110-1301  USA
! *
! *****************************************************************************/
!
!/******************************************************************************
!
!/******************************************************************************
! *
! *  A module for solving the one-dimensional Timoshenko beam equations
! *
! *                  m*d^2u/dt^2 - N'= F  on (0,L)
! *  IM*d^2(theta)/dt^2 - M' - t x N = G  on (0,L).
! *
! *  with the stress resultants N and M representing forces and moments 
! *  experienced by the cross section of a beam and t giving the tangent
! *  vector to the beam axis. By using the constitutive equation, the 
! *  displacement u:[0,L] -> R^3 and the so-called rotation theta:[0,L] -> R^3 
! *  are approximated by a finite element discretization. The fields
! *  m and IM are the beam mass per unit length and the mass moment of
! *  inertia of the cross section. In addition to Dirichlet constraints,
! *  the force and the moment can be specified as nodal loads.
! *
! *  One may assume the quadratic approximation of the deflection and 
! *  the linear approximation of the rotation and eliminate the quadratic
! *  bubble part of the deflection by static condensation. This gives
! *  an approximation over the lowest-order nodal mesh. This approximation
! *  may be generated by giving the element definition "Element = p:1 b:1". 
! *  Higher-order versions are not yet available.
! *
! *  Authors: Mika Malinen
! *  Email:   mika.malinen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: May 27, 2019
! *
! *****************************************************************************/

!------------------------------------------------------------------------------
SUBROUTINE TimoshenkoSolver_Init0(Model, Solver, dt, Transient)
!------------------------------------------------------------------------------
  USE DefUtils
  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Model_t) :: Model
  TYPE(Solver_t) :: Solver
  REAL(KIND=dp) :: dt
  LOGICAL :: Transient
!------------------------------------------------------------------------------
  TYPE(ValueList_t), POINTER :: SolverPars
!------------------------------------------------------------------------------
  SolverPars => GetSolverParams()

  CALL ListAddInteger(SolverPars, 'Variable DOFs', 6)
  CALL ListAddNewString(SolverPars, 'Variable', 'Deflection[U:3 Theta:3]')
  CALL ListAddNewString(SolverPars, 'Element', 'p:1 b:1')

  CALL ListAddLogical(SolverPars, 'Bubbles in Global System', .FALSE.)
!------------------------------------------------------------------------------
END SUBROUTINE TimoshenkoSolver_Init0
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
SUBROUTINE TimoshenkoSolver(Model, Solver, dt, TransientSimulation)
!------------------------------------------------------------------------------
  USE DefUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Model_t) :: Model
  TYPE(Solver_t) :: Solver
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Element_t), POINTER :: Element
  LOGICAL :: Found
  INTEGER :: K, Active, n, nb, nd
  INTEGER :: iter, maxiter
  REAL(KIND=dp) :: Norm
!------------------------------------------------------------------------------

  CALL DefaultStart()
  
  maxiter = ListGetInteger(GetSolverParams(), &
      'Nonlinear System Max Iterations', Found, minv=1)
  IF (.NOT. Found ) maxiter = 1

  !--------------------------
  ! Nonlinear iteration loop:
  !--------------------------
  DO iter=1,maxiter
    !-----------------
    ! System assembly:
    !-----------------
    CALL DefaultInitialize()
    Active = GetNOFActive()
    DO K=1,Active
      Element => GetActiveElement(K)

      IF ( .NOT. (GetElementFamily(Element) == 2) ) CYCLE

      n  = GetElementNOFNodes()
      nd = GetElementNOFDOFs()
      nb = GetElementNOFBDOFs()

      CALL LocalMatrix(Element, n, nd+nb, nb, TransientSimulation)
    END DO

    CALL DefaultFinishBulkAssembly()

    !CALL DefaultFinishBoundaryAssembly()
    CALL DefaultFinishAssembly()
    CALL DefaultDirichletBCs()

    !-----------------------
    ! Call a linear solver:
    !-----------------------
    Norm = DefaultSolve()
    IF ( DefaultConverged() ) EXIT    

  END DO

  CALL DefaultFinish()
  
CONTAINS

!------------------------------------------------------------------------------
! Integrate and assemble the local stiffness matrix. The local DOFs always 
! correspond to the displacement components along the tangent direction and the
! principal axes of the cross section. The transformation to global DOFs is done
! within this subroutine. The stiffness matrix K corresponding to the global 
! DOFs is thus obtained as K = R^T k R and the RHS vector F is obtained as 
! F = R^T f.
!------------------------------------------------------------------------------
  SUBROUTINE LocalMatrix(Element, n, nd, nb, TransientSimulation)
!------------------------------------------------------------------------------
    IMPLICIT NONE
    TYPE(Element_t), POINTER, INTENT(IN) :: Element
    INTEGER, INTENT(IN) :: n, nd, nb
    LOGICAL, INTENT(IN) :: TransientSimulation
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: BodyForce, Material
    TYPE(Nodes_t) :: Nodes, LocalNodes
    TYPE(GaussIntegrationPoints_t) :: IP

    LOGICAL :: Found, Stat

    INTEGER :: DOFs
    INTEGER :: i, t, p, q
    INTEGER :: i0, p0, q0

    REAL(KIND=dp), POINTER :: ArrayPtr(:,:) => NULL()
    REAL(KIND=dp), POINTER :: StiffBlock(:,:), MassBlock(:,:)
    REAL(KIND=dp), DIMENSION(3), PARAMETER :: ZBasis = (/ 0.0d0, 0.0d0, 0.1d1 /)

    REAL(KIND=dp), TARGET :: Mass(6*nd,6*nd), Stiff(6*nd,6*nd), Damp(6*nd,6*nd)
    REAL(KIND=dp) :: Force(6*nd)
    REAL(KIND=dp) :: RBlock(3,3), R(6*nd,6*nd)
    REAL(KIND=dp) :: Basis(nd), dBasis(nd,3), DetJ, Weight
    REAL(KIND=dp) :: Youngs_Modulus(n), Shear_Modulus(n), Area(n), Density(n)
    REAL(KIND=dp) :: Torsional_Constant(n) 
    REAL(KIND=dp) :: Area_Moment_2(n), Area_Moment_3(n)
    REAL(KIND=dp) :: Mass_Inertia_Moment(n) 
    REAL(KIND=dp) :: Load(3,n), f(3)
    REAL(KIND=dp) :: E, A, G, rho
    REAL(KIND=dp) :: EA, GA, MOI, Mass_per_Length 
    REAL(KIND=dp) :: E_diag(3)
    
    REAL(KIND=dp) :: p1(3), p2(3), e1(3), e2(3), e3(3)
    REAL(KIND=dp) :: L, Norm

    SAVE Nodes, LocalNodes
!------------------------------------------------------------------------------
    IF (n > 2) CALL Fatal('BeamSolver3D', &
        'Only 2-node background meshes supported currently')

    DOFs = 6
!    dim = CoordinateSystemDimension()

    CALL GetElementNodes(Nodes)

    Mass  = 0.0_dp
    Stiff = 0.0_dp
    Damp = 0.0_dp
    Force = 0.0_dp

    BodyForce => GetBodyForce()
    IF ( ASSOCIATED(BodyForce) ) THEN
      !
      ! Force components refer to the basis of the global frame:
      !
      Load(1,1:n) = GetReal(BodyForce, 'Body Force 1', Found)
      Load(2,1:n) = GetReal(BodyForce, 'Body Force 2', Found)
      Load(3,1:n) = GetReal(BodyForce, 'Body Force 3', Found)
    ELSE
      Load = 0.0_dp
    END IF

    Material => GetMaterial()
    Youngs_Modulus(1:n) = GetReal(Material, 'Youngs Modulus', Found)
    Shear_Modulus(1:n) = GetReal(Material, 'Shear Modulus', Found)
    Area(1:n) = GetReal(Material, 'Cross Section Area', Found)
    Torsional_Constant(1:n) = GetReal(Material, 'Torsional Constant', Found)
    Area_Moment_2(1:n) = GetReal(Material, 'Second Moment of Area 2', Found)
    Area_Moment_3(1:n) = GetReal(Material, 'Second Moment of Area 3', Found)

    IF (TransientSimulation) THEN
      Density(1:n) = GetReal(Material, 'Density', Found)
    END IF

    !
    ! Compute the tangent vector e1 to the beam axis:
    !
    p1(1) = Nodes % x(1)
    p1(2) = Nodes % y(1)
    p1(3) = Nodes % z(1)
    p2(1) = Nodes % x(2)
    p2(2) = Nodes % y(2)
    p2(3) = Nodes % z(2)
    e1 = p2 - p1
    L = SQRT(SUM(e1(:)**2))
    e1 = 1.0_dp/L * e1
    !
    ! Cross section parameters are given with respect to a local frame. 
    ! Determine its orientation:
    !
    ArrayPtr => ListGetConstRealArray(Material, 'Principal Direction 2', Found)
    IF (Found) THEN
      e2 = 0.0d0
      DO i=1,SIZE(ArrayPtr,1)
        e2(i) = ArrayPtr(i,1)
      END DO
      Norm = SQRT(SUM(e2(:)**2))
      e2 = 1.0_dp/Norm * e2     
    ELSE
      e2 = -ZBasis
    END IF
    IF (ABS(DOT_PRODUCT(e1,e2)) > 100.0_dp * AEPS) CALL Fatal('BeamSolver3D', &
        'Principal Direction 2 should be orthogonal to the beam axis')
    e3 = CrossProduct(e1, e2)

    !
    ! Build the transformation matrix in order to switch to the global DOFs
    !
    R = 0.0d0
    RBlock(1,1:3) = e1(1:3)
    RBlock(2,1:3) = e2(1:3)
    RBlock(3,1:3) = e3(1:3)
    DO i=1,nd-nb
      i0 = (i-1)*DOFs
      R(i0+1:i0+3,i0+1:i0+3) =  RBlock(1:3,1:3)
      R(i0+4:i0+6,i0+4:i0+6) =  RBlock(1:3,1:3)
    END DO
 
    !
    ! Allocate an additional variable so as to write nodes data with respect to
    ! the local frame.
    !
    IF (.NOT. ASSOCIATED(LocalNodes % x)) THEN
      ALLOCATE(LocalNodes % x(n), LocalNodes % y(n), LocalNodes % z(n) ) 
      LocalNodes % NumberOfNodes = n
      LocalNodes % y(:) = 0.0_dp
      LocalNodes % z(:) = 0.0_dp
    END IF
    LocalNodes % x(1) = 0.0d0
    LocalNodes % x(2) = L

    !-----------------------
    ! Numerical integration:
    !-----------------------
    IP = GaussPoints( Element )
    DO t=1,IP % n
      !--------------------------------------------------------------
      ! Basis function values & derivatives at the integration point:
      !--------------------------------------------------------------
      stat = ElementInfo(Element, LocalNodes, IP % U(t), IP % V(t), &
              IP % W(t), detJ, Basis, dBasis)

      !------------------------------------------
      ! The model data at the integration point:
      !------------------------------------------
      f(1) = SUM(Basis(1:n) * Load(1,1:n))
      f(2) = SUM(Basis(1:n) * Load(2,1:n))
      f(3) = SUM(Basis(1:n) * Load(3,1:n))      

      ! TO DO: Add option to give the applied moment load

      E = SUM(Basis(1:n) * Youngs_Modulus(1:n))
      G = SUM(Basis(1:n) * Shear_Modulus(1:n))      
      A = SUM(Basis(1:n) * Area(1:n))

      E_diag(1) = G * SUM(Basis(1:n) * Torsional_Constant(1:n))
      E_diag(2) = E * SUM(Basis(1:n) * Area_Moment_2(1:n))
      E_diag(3) = E * SUM(Basis(1:n) * Area_Moment_3(1:n)) 

      IF (TransientSimulation) THEN
        rho = SUM(Basis(1:n) * Density(1:n))
        MOI = rho/E * sqrt(E_diag(2)**2 + E_diag(3)**2)
        Mass_per_Length = rho * A
      END IF

      GA = G*A
      EA = E*A

      ! TO DO: Add option to give shear correction factors

      Weight = IP % s(t) * DetJ

      DO p=1,nd
        p0 = (p-1)*DOFs
        DO q=1,nd
          q0 = (q-1)*DOFs
          StiffBlock => Stiff(p0+1:p0+DOFs,q0+1:q0+DOFs)
          MassBlock => Mass(p0+1:p0+DOFs,q0+1:q0+DOFs)
          !
          ! (Du',v'):
          !
          StiffBlock(1,1) = StiffBlock(1,1) + &
              EA * dBasis(q,1) * dBasis(p,1) * Weight
          StiffBlock(2,2) = StiffBlock(2,2) + &
              GA * dBasis(q,1) * dBasis(p,1) * Weight
          StiffBlock(3,3) = StiffBlock(3,3) + &
              GA * dBasis(q,1) * dBasis(p,1) * Weight
  
          IF (TransientSimulation) THEN
            MassBlock(1,1) = MassBlock(1,1) + &
                Mass_per_Length * Basis(q) * Basis(p) * Weight
            MassBlock(2,2) = MassBlock(2,2) + &
                Mass_per_Length * Basis(q) * Basis(p) * Weight
            MassBlock(3,3) = MassBlock(3,3) + &
                Mass_per_Length * Basis(q) * Basis(p) * Weight
          END IF

          IF (q > n) CYCLE
          !
          ! -(D theta x t,v'):
          !
          StiffBlock(2,6) = StiffBlock(2,6) - &
              GA * Basis(q) * dBasis(p,1) * Weight
          StiffBlock(3,5) = StiffBlock(3,5) + &
              GA * Basis(q) * dBasis(p,1) * Weight
        END DO
        
        Force(p0+1) = Force(p0+1) + Weight * DOT_PRODUCT(f,e1)* Basis(p)
        Force(p0+2) = Force(p0+2) + Weight * DOT_PRODUCT(f,e2)* Basis(p)
        Force(p0+3) = Force(p0+3) + Weight * DOT_PRODUCT(f,e3)* Basis(p)

        IF (p > n) CYCLE

        DO q=1,nd
          q0 = (q-1)*DOFs
          StiffBlock => Stiff(p0+1:p0+DOFs,q0+1:q0+DOFs)
          MassBlock => Mass(p0+1:p0+DOFs,q0+1:q0+DOFs)
          !
          ! -(D u',psi x t):
          !
          StiffBlock(5,3) = StiffBlock(5,3) + &
              GA * Basis(p) * dBasis(q,1) * Weight
          StiffBlock(6,2) = StiffBlock(6,2) - &
              GA * Basis(p) * dBasis(q,1) * Weight

          IF (q > n) CYCLE

          !
          ! (E theta',psi') + (D theta x t,psi x t):
          !
          StiffBlock(4,4) = StiffBlock(4,4) + &
              E_diag(1) * dBasis(q,1) * dBasis(p,1) * Weight
          StiffBlock(5,5) = StiffBlock(5,5) + &
              E_diag(2) * dBasis(q,1) * dBasis(p,1) * Weight + &
              GA * Basis(p) * Basis(q) * Weight
          StiffBlock(6,6) = StiffBlock(6,6) + &
              E_diag(3) * dBasis(q,1) * dBasis(p,1) * Weight + &
              GA * Basis(p) * Basis(q) * Weight

          IF (TransientSimulation) THEN
            MassBlock(4,4) = MassBlock(4,4) + MOI * Basis(q) * Basis(p) * Weight
            MassBlock(5,5) = MassBlock(5,5) + rho/E * E_diag(2) * &
                Basis(q) * Basis(p) * Weight
            MassBlock(6,6) = MassBlock(6,6) + rho/E * E_diag(3) * &
                Basis(q) * Basis(p) * Weight
          END IF

        END DO
      END DO
    END DO

    CALL BeamCondensate(nd-nb, nb, DOFs, 3, Stiff, Force)

    !-------------------------------------------------------
    ! Transform to the global DOFs:
    !-------------------------------------------------------
    DOFs = (nd-nb)*DOFs
    Stiff(1:DOFs,1:DOFs) = MATMUL(TRANSPOSE(R(1:DOFs,1:DOFs)), &
        MATMUL(Stiff(1:DOFs,1:DOFs),R(1:DOFs,1:DOFs)))
    Force(1:DOFs) = MATMUL(TRANSPOSE(R(1:DOFs,1:DOFs)),Force(1:DOFs))

    IF (TransientSimulation) CALL Default2ndOrderTime(Mass, Damp, Stiff, Force)

    CALL DefaultUpdateEquations(Stiff, Force)
!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrix
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
SUBROUTINE BeamCondensate(n, nb, dofs, dim, K, F, F1 )
!------------------------------------------------------------------------------
    USE LinearAlgebra
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n    ! Nodes after condensation
    INTEGER, INTENT(IN) :: nb   ! The number of bubble basis functions
    INTEGER, INTENT(IN) :: dofs ! DOFs per node
    INTEGER, INTENT(IN) :: dim  ! The first dim fields have bubbles
    REAL(KIND=dp), INTENT(INOUT) :: K(:,:)          ! The stiffness matrix
    REAL(KIND=dp), INTENT(INOUT) :: F(:)            ! The RHS vector
    REAL(KIND=dp), OPTIONAL, INTENT(INOUT) :: F1(:) ! Some other RHS vector
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Kbl(nb*dim,n*dofs), Kbb(nb*dim,nb*dim), Fb(nb*dim)
    REAL(KIND=dp) :: Klb(n*dofs,nb*dim)

    INTEGER :: i, m, p, Cdofs(dofs*n), Bdofs(dim*nb)
!------------------------------------------------------------------------------

    Cdofs(1:n*dofs) = (/ (i, i=1,n*dofs) /)

    m = 0
    DO p = 1,nb
      DO i = 1,dim
        m = m + 1
        Bdofs(m) = dofs*(n+p-1) + i
      END DO
    END DO

    Kbb = K(Bdofs,Bdofs)
    Kbl = K(Bdofs,Cdofs)
    Klb = K(Cdofs,Bdofs)
    Fb  = F(Bdofs)

    CALL InvertMatrix( Kbb,nb*dim )

    F(1:dofs*n) = F(1:dofs*n) - MATMUL( Klb, MATMUL( Kbb, Fb ) )
    K(1:dofs*n,1:dofs*n) = &
        K(1:dofs*n,1:dofs*n) - MATMUL( Klb, MATMUL( Kbb,Kbl ) )

    IF (PRESENT(F1)) THEN
      Fb  = F1(Bdofs)
      F1(1:dofs*n) = F1(1:dofs*n) - MATMUL( Klb, MATMUL( Kbb, Fb ) )
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE BeamCondensate
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
END SUBROUTINE TimoshenkoSolver
!------------------------------------------------------------------------------
